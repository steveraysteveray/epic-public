# baseURI: http://qudt.org/1.2/schema/datatype
# imports: http://qudt.org/1.2/schema/qudt
# imports: http://qudt.org/1.2/vocab/datatype
# imports: http://www.linkedmodel.org/1.0/schema/dtype
# imports: http://www.linkedmodel.org/1.2/schema/vaem
# imports: http://www.linkedmodel.org/1.2/schema/vaem-xics
# imports: http://www.linkedmodel.org/1.2/schema/vaem-xina
# imports: http://www.w3.org/2004/02/skos/core

# c14n-version: 3
@prefix datatype: <http://qudt.org/vocab/datatype#> .
@prefix dc: <http://purl.org/dc/elements/1.1/> .
@prefix dtype: <http://www.linkedmodel.org/schema/dtype#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix prov: <http://www.w3.org/ns/prov#> .
@prefix qudt: <http://qudt.org/schema/qudt#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sc: <http://data.nasa.gov/core/schema/sc#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix vaem: <http://www.linkedmodel.org/schema/vaem#> .
@prefix voag: <http://voag.linkedmodel.org/schema/voag#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
dc:contributor
  rdf:type owl:AnnotationProperty ;
  rdfs:label "contributor"^^xsd:string ;
  rdfs:range xsd:string ;
.
dc:creator
  rdf:type owl:AnnotationProperty ;
  rdfs:label "creator"^^xsd:string ;
  rdfs:range xsd:string ;
.
dc:description
  rdf:type owl:AnnotationProperty ;
  rdfs:label "description"^^xsd:string ;
  rdfs:range xsd:string ;
.
dc:rights
  rdf:type owl:AnnotationProperty ;
  rdfs:label "rights"^^xsd:string ;
  rdfs:range xsd:string ;
.
dc:subject
  rdf:type owl:AnnotationProperty ;
  rdfs:label "subject"^^xsd:string ;
  rdfs:range xsd:string ;
.
dc:title
  rdf:type owl:AnnotationProperty ;
  rdfs:label "title"^^xsd:string ;
  rdfs:range xsd:string ;
.
<http://qudt.org/1.2/schema/datatype>
  rdf:type owl:Ontology ;
  dc:contributor "Chip Masters"^^xsd:string ;
  dc:contributor "Daniel Mekonnen"^^xsd:string ;
  dc:creator "Ralph Hodgson"^^xsd:string ;
  dc:description "The QUDT 'Datatype' ontology extends VAEM 'DTYPE' with further classes and properties for the specification of data types."^^xsd:string ;
  dc:subject "Datatypes"^^xsd:string ;
  dc:title "The QUDT Datatype Ontology"^^xsd:string ;
  vaem:hasCatalogEntry voag:QUDT-SchemaCatalogEntry ;
  vaem:hasGraphRole vaem:SchemaGraph ;
  vaem:hasLicenseType voag:CC-SHAREALIKE_3PT0-US ;
  vaem:intent "This ontology is to be used by other ontologies that need to reference type definitions."^^xsd:string ;
  vaem:namespace "http://qudt.org/schema/dtype#"^^xsd:string ;
  vaem:namespacePrefix "type"^^xsd:string ;
  vaem:specificity "1"^^xsd:int ;
  vaem:url "http://qudt.org/1.2/schema/dtype"^^xsd:anyURI ;
  rdfs:label "datatype"^^xsd:string ;
  owl:imports <http://qudt.org/1.2/schema/qudt> ;
  owl:imports <http://qudt.org/1.2/vocab/datatype> ;
  owl:imports <http://www.linkedmodel.org/1.0/schema/dtype> ;
  owl:imports <http://www.linkedmodel.org/1.2/schema/vaem> ;
  owl:imports <http://www.linkedmodel.org/1.2/schema/vaem-xics> ;
  owl:imports <http://www.linkedmodel.org/1.2/schema/vaem-xina> ;
  owl:imports <http://www.w3.org/2004/02/skos/core> ;
  owl:versionInfo "$Id: SCHEMA_datatype-v1.2.ttl 1954 2013-04-20 17:27:02Z rhodgson $"^^xsd:string ;
.
qudt:AbstractDatatype
  rdf:type owl:Class ;
  dc:description "An \\textit{Abstract Datatype} (ADT) is a specification of a set of data and the set of operations that can be performed on the data. Such a data type is abstract in the sense that it is independent of various concrete implementations. The definition can be mathematical, or it can be programmed as an interface. A first class ADT supports the creation of multiple instances of the ADT, and the interface normally provides a constructor, which returns an abstract handle to new data, and several operations, which are functions accepting the abstract handle as an argument."^^xsd:string ;
  rdfs:label "Abstract Datatype"^^xsd:string ;
  rdfs:subClassOf qudt:StructuredDatatype ;
.
qudt:AerospaceCoordinateSystem
  rdf:type owl:Class ;
  rdfs:label "Aerospace coordinate system"^^xsd:string ;
  rdfs:subClassOf qudt:CoordinateSystem ;
.
qudt:AlgebraicDatatype
  rdf:type owl:Class ;
  dc:description """An \\textit{Algebraic Datatype} is a datatype each of whose values are data from other data types wrapped in one of the constructors of the data type. Any wrapped datum is an argument to the constructor. In contrast to other data types, the constructor is not executed and the only way to operate on the data is to unwrap the constructor using pattern matching.

The most common algebraic data type is a list with two constructors: Nil or [] for an empty list, and Cons (an abbreviation of constructor), ::, or : for the combination of a new element with a shorter list (for example (Cons 1 '(2 3 4)) or 1:[2,3,4]).

Special cases of algebraic types are product types i.e. records (only one constructor) and enumerated types (many constructors with no arguments). Algebraic types are one kind of composite type (i.e. a type formed by combining other types).

An algebraic data type may also be an abstract data type (ADT) if it is exported from a module without its constructors. Values of such a type can only be manipulated using functions defined in the same module as the type itself."""^^xsd:string ;
  rdfs:label "Algebraic Datatype"^^xsd:string ;
  rdfs:subClassOf qudt:StructuredDatatype ;
.
qudt:AlignmentType
  rdf:type owl:Class ;
  dc:description "Specifies how a physical data field is aligned. The alignment could be at a bit, byte or word boundary."^^xsd:string ;
  rdfs:label "Alignment type"^^xsd:string ;
  rdfs:subClassOf qudt:EnumeratedValue ;
  owl:oneOf (
      <http://qudt.org/vocab/type/BitAligned>
      <http://qudt.org/vocab/type/ByteAligned>
      <http://qudt.org/vocab/type/WordAligned>
    ) ;
.
qudt:Array
  rdf:type owl:Class ;
  dc:description "An array is represented as ordered entries of values arranged according to the dimensions given. The dimensions are given as a list of integers where each integer is the cardinality of each dimension. The number of dimensions is specified in the attribute 'dimensionality'. Optionally a reference can be made to a variable, whose values are the array entries. The data type of the array entries is an optional field, 'elementType', which points to a data type definition. If the data type is given, then it applies to all elements.  If it is not given then the elements can be of different types for each position in the array. The property 'type:typeMatrix' must refer to a matrix of types.  If a default value is given this can be used to place the appropriate value in a cell when an entry value is not known. If no dimensionality or dimension vector is specified the array is under-specified but still legitimate as a place-holder for a data type."^^xsd:string ;
  rdfs:label "Array Type"^^xsd:string ;
  rdfs:subClassOf qudt:CompositeDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:ArrayDataOrderType ;
      owl:onProperty qudt:dataOrder ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:DimensionVector ;
      owl:onProperty qudt:hasDimensionVector ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom <http://qudt.org/schema/type#TypeMatrix> ;
      owl:onProperty qudt:typeMatrix ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:typeMatrix ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:byRow ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:dataOrder ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:dimensionality ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:hasDimensionVector ;
    ] ;
.
qudt:ArrayDataOrderType
  rdf:type owl:Class ;
  rdfs:label "Array data order type"^^xsd:string ;
  rdfs:subClassOf qudt:EnumeratedValue ;
  owl:oneOf (
      qudt:ByColumn
      qudt:ByRow
      qudt:ByLeftMostIndex
    ) ;
.
qudt:ArrayDataOrderTypeEnumeration
  rdf:type qudt:Enumeration ;
  qudt:defaultValue qudt:ByRow ;
  dtype:value qudt:ByColumn ;
  dtype:value qudt:ByLeftMostIndex ;
  dtype:value qudt:ByRow ;
  rdfs:label "Array data order type enumeration"^^xsd:string ;
.
qudt:ArrayIndex
  rdf:type owl:Class ;
  dc:description "An Array Index Type is a data type that specifies the properties of data structures that hold array indexes."^^xsd:string ;
  vaem:description "An Array Index Type is a data type that specifies the properties of data structures that hold array indexes."^^xsd:string ;
  rdfs:label "Array Index Type"^^xsd:string ;
  rdfs:subClassOf qudt:Vector ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue <http://qudt.org/vocab/type/UNSIGNED-INTEGER> ;
      owl:onProperty qudt:elementType ;
    ] ;
.
qudt:AssociativeArray
  rdf:type owl:Class ;
  dc:description "An Associative Array (or Map) is an abstract data type composed of a collection of keys and a collection of values, where each key is associated with one value. The operation of finding the value associated with a key is called a lookup or indexing, and this is the most important operation supported by an associative array. The relationship between a key and its value is sometimes called a mapping or binding." ;
  vaem:description "An Associative Array (or Map) is an abstract data type composed of a collection of keys and a collection of values, where each key is associated with one value. The operation of finding the value associated with a key is called a lookup or indexing, and this is the most important operation supported by an associative array. The relationship between a key and its value is sometimes called a mapping or binding." ;
  rdfs:label "Associative Array"^^xsd:string ;
  rdfs:subClassOf qudt:Collection ;
  owl:equivalentClass qudt:Map ;
.
qudt:AuralCueEnumeration
  rdf:type owl:Class ;
  rdfs:label "Aural Cue Enumeration"^^xsd:string ;
  rdfs:subClassOf qudt:ModalEnumeration ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom <http://qudt.org/schema/type#AuralCue> ;
      owl:onProperty qudt:defaultValue ;
    ] ;
  owl:disjointWith qudt:IconicCueEnumeration ;
  owl:disjointWith qudt:KinestheticCueEnumeration ;
  owl:disjointWith qudt:VisualCueEnumeration ;
.
qudt:AxialOrientationType
  rdf:type owl:Class ;
  dc:description "The axial orientation of a coordinate system frame axis."^^xsd:string ;
  rdfs:label "Axial Orientation Type"^^xsd:string ;
  rdfs:subClassOf qudt:EnumeratedValue ;
  owl:oneOf (
      <http://qudt.org/vocab/type/PositiveZ>
      <http://qudt.org/vocab/type/PositiveY>
      <http://qudt.org/vocab/type/NegativeY>
      <http://qudt.org/vocab/type/NegativeZ>
      <http://qudt.org/vocab/type/PositiveX>
      <http://qudt.org/vocab/type/NegativeX>
    ) ;
.
qudt:BalancedTree
  rdf:type owl:Class ;
  dc:description "A Balanced Tree Type is a data type that defines the properties of data structures that represent balanced trees. A balanced tree is a tree where no leaf is much farther away from the root than any other leaf. Different balancing schemes allow different definitions of \"much farther\" and different amounts of work to keep them balanced."^^xsd:string ;
  vaem:description "A Balanced Tree Type is a data type that defines the properties of data structures that represent balanced trees. A balanced tree is a tree where no leaf is much farther away from the root than any other leaf. Different balancing schemes allow different definitions of \"much farther\" and different amounts of work to keep them balanced."^^xsd:string ;
  rdfs:label "Balanced Tree Type"^^xsd:string ;
  rdfs:subClassOf qudt:Tree ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:maxDepth ;
    ] ;
.
qudt:BigIntegerType
  rdf:type owl:Class ;
  vaem:description "A Big Integer is an integer that can be represented in eight octets (64 bits) of machine memory. Big integers may be signed or unsigned."^^xsd:string ;
  rdfs:label "Big Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:IntegerDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "64"^^xsd:int ;
      owl:onProperty qudt:bits ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "8"^^xsd:int ;
      owl:onProperty qudt:octets ;
    ] ;
.
qudt:BinaryTree
  rdf:type owl:Class ;
  dc:description "A Binary Tree Type is a data type that defines the properties of data structures that represent binary trees. A binary tree is a tree in which each node has at most 2 children. "^^xsd:string ;
  vaem:description "A Binary Tree Type is a data type that defines the properties of data structures that represent binary trees. A binary tree is a tree in which each node has at most 2 children. "^^xsd:string ;
  rdfs:label "Binary Tree Type"^^xsd:string ;
  rdfs:subClassOf qudt:Tree ;
.
qudt:BitEncodingType
  rdf:type owl:Class ;
  dc:description "A bit encoding is a correspondence between the two possible values of a bit, 0 or 1, and some interpretation. For example, in a boolean encoding, a bit denotes a truth value, where 0 corresponds to False and 1 corresponds to True."^^xsd:string ;
  rdfs:label "Bit Encoding"^^xsd:string ;
  rdfs:subClassOf qudt:Encoding ;
.
qudt:BitField
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "bitfield"^^xsd:string ;
  rdfs:subClassOf xsd:string ;
.
qudt:BitField1
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "Bit field of 1 bit"^^xsd:string ;
  rdfs:subClassOf qudt:BitField ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:length "1"^^xsd:nonNegativeInteger ;
          ]
          [
            xsd:pattern "[0-1]"^^xsd:string ;
          ]
        ) ;
    ] ;
.
qudt:BitField10
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "bit field of 10 bits"^^xsd:string ;
  rdfs:subClassOf qudt:BitField ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:length "10"^^xsd:nonNegativeInteger ;
          ]
          [
            xsd:pattern "[0-1]{10}"^^xsd:string ;
          ]
        ) ;
    ] ;
.
qudt:BitField11
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "bit field of 11 bits"^^xsd:string ;
  rdfs:subClassOf qudt:BitField ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:length "11"^^xsd:nonNegativeInteger ;
          ]
          [
            xsd:pattern "[0-1]{11}"^^xsd:string ;
          ]
        ) ;
    ] ;
.
qudt:BitField12
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "bit field of 12 bits"^^xsd:string ;
  rdfs:subClassOf qudt:BitField ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:length "12"^^xsd:nonNegativeInteger ;
          ]
          [
            xsd:pattern "[0-1]{12}"^^xsd:string ;
          ]
        ) ;
    ] ;
.
qudt:BitField2
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "bit field of 2 bits"^^xsd:string ;
  rdfs:subClassOf qudt:BitField ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:length "2"^^xsd:nonNegativeInteger ;
          ]
          [
            xsd:pattern "[0-1]{2}"^^xsd:string ;
          ]
        ) ;
    ] ;
.
qudt:BitField3
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "bit field of 3 bits"^^xsd:string ;
  rdfs:subClassOf qudt:BitField ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:length "3"^^xsd:nonNegativeInteger ;
          ]
          [
            xsd:pattern "[0-1]{3}"^^xsd:string ;
          ]
        ) ;
    ] ;
.
qudt:BitField4
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "bit field of 4 bits"^^xsd:string ;
  rdfs:subClassOf qudt:BitField ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:length "4"^^xsd:nonNegativeInteger ;
          ]
          [
            xsd:pattern "[0-1]{4}"^^xsd:string ;
          ]
        ) ;
    ] ;
.
qudt:BitField5
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "bit field of 5 bits"^^xsd:string ;
  rdfs:subClassOf qudt:BitField ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:length "5"^^xsd:nonNegativeInteger ;
          ]
          [
            xsd:pattern "[0-1]{5}"^^xsd:string ;
          ]
        ) ;
    ] ;
.
qudt:BitField6
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "bit field of 6 bits"^^xsd:string ;
  rdfs:subClassOf qudt:BitField ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:length "6"^^xsd:nonNegativeInteger ;
          ]
          [
            xsd:pattern "[0-1]{6}"^^xsd:string ;
          ]
        ) ;
    ] ;
.
qudt:BitField7
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "bit field of 6 bits"^^xsd:string ;
  rdfs:subClassOf qudt:BitField ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:length "7"^^xsd:nonNegativeInteger ;
          ]
          [
            xsd:pattern "[0-1]{7}"^^xsd:string ;
          ]
        ) ;
    ] ;
.
qudt:BitField8
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "bit field of 8 bits"^^xsd:string ;
  rdfs:subClassOf qudt:BitField ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:length "8"^^xsd:nonNegativeInteger ;
          ]
          [
            xsd:pattern "[0-1]{8}"^^xsd:string ;
          ]
        ) ;
    ] ;
.
qudt:BitField9
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "bit field of 9 bits"^^xsd:string ;
  rdfs:subClassOf qudt:BitField ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:length "9"^^xsd:nonNegativeInteger ;
          ]
          [
            xsd:pattern "[0-1]{9}"^^xsd:string ;
          ]
        ) ;
    ] ;
.
qudt:BitFieldType
  rdf:type owl:Class ;
  dc:description "A bit field is a common idiom used in computer programming to store a set of Boolean datatype flags compactly, as a series of bits. The bit field is stored in an integral type of known, fixed bit-width. Each Boolean flag is stored in a separate bit. Usually the source code will define a set of constants, each a power of two, that semantically associate each individual bit with its respective Boolean flag. The bitwise operators and, or, and not are used in combination to set, reset and test the flags."^^xsd:string ;
  rdfs:label "Bit Field Type"^^xsd:string ;
  rdfs:subClassOf qudt:ScalarDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:BitField ;
      owl:onProperty qudt:encodedValue ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:encodedValue ;
    ] ;
.
qudt:BooleanEncodingType
  rdf:type owl:Class ;
  rdfs:label "Boolean encoding type"^^xsd:string ;
  rdfs:subClassOf qudt:Encoding ;
.
qudt:BooleanType
  rdf:type owl:Class ;
  dc:description "A boolean data type can take on only two values."^^xsd:string ;
  vaem:description "A boolean data type can take on only two values."^^xsd:string ;
  rdfs:label "Boolean Type"^^xsd:string ;
  rdfs:subClassOf qudt:OrdinalType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:BooleanEncodingType ;
      owl:onProperty qudt:encoding ;
    ] ;
.
qudt:ByColumn
  rdf:type qudt:ArrayDataOrderType ;
  dtype:literal "byColumn"^^xsd:string ;
  rdfs:label "By column"^^xsd:string ;
.
qudt:ByLeftMostIndex
  rdf:type qudt:ArrayDataOrderType ;
  dtype:literal "byLeftMostIndex"^^xsd:string ;
  rdfs:label "By left most index"^^xsd:string ;
.
qudt:ByRow
  rdf:type qudt:ArrayDataOrderType ;
  dtype:literal "byRow"^^xsd:string ;
  rdfs:label "By row"^^xsd:string ;
.
qudt:ByteEncodingType
  rdf:type owl:Class ;
  dc:description "This class contains the various ways that information may be encoded into bytes."^^xsd:string ;
  rdfs:label "Byte Encoding"^^xsd:string ;
  rdfs:subClassOf qudt:Encoding ;
.
qudt:CRC32
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "CRC-32"^^xsd:string ;
  rdfs:subClassOf xsd:integer ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:integer ;
      owl:withRestrictions (
          [
            xsd:minInclusive 0 ;
          ]
          [
            xsd:maxInclusive "4294967295"^^xsd:unsignedInt ;
          ]
        ) ;
    ] ;
.
qudt:CT_COUNTABLY-INFINITE
  rdf:type qudt:CardinalityType ;
  qudt:description "A set of numbers is called countably infinite if there is a way to enumerate them.  Formally this is done with a bijection function that associates each number in the set with exactly one of the positive integers.  The set of all fractions is also countably infinite.  In other words, any set $X$ that has the same cardinality as the set of the natural numbers, or $| X | \\; =  \\; | \\mathbb N | \\; = \\; \\aleph0$, is said to be a countably infinite set."^^xsd:string ;
  qudt:literal "countable"^^xsd:string ;
  rdfs:label "Countably Infinite Cardinality Type"^^xsd:string ;
  prov:wasInfluencedBy <http://www.math.vanderbilt.edu/~schectex/courses/infinity.pdf> ;
.
qudt:CT_FINITE
  rdf:type qudt:CardinalityType ;
  qudt:description "Any set $X$ with cardinality less than that of the natural numbers, or $| X | \\; <  \\; | \\mathbb N | $, is said to be a finite set."^^xsd:string ;
  qudt:literal "finite"^^xsd:string ;
  rdfs:label "Finite Cardinality Type"^^xsd:string ;
.
qudt:CT_UNCOUNTABLE
  rdf:type qudt:CardinalityType ;
  qudt:description "Any set with cardinality greater than that of the natural numbers, or $| X | \\; >  \\; | \\mathbb N | $,  for example $| R| \\; =  \\;  c  \\; > |\\mathbb N |$, is said to be uncountable."^^xsd:string ;
  qudt:literal "uncountable"^^xsd:string ;
  rdfs:label "Uncountable Cardinality Type"^^xsd:string ;
  skos:prefLabel "Uncountable Cardinality Type"^^xsd:string ;
.
qudt:CardinalityType
  rdf:type owl:Class ;
  dc:description "In mathematics, the cardinality of a set is a measure of the number of elements of the set.  For example, the set $A = {2, 4, 6}$ contains 3 elements, and therefore $A$ has a cardinality of 3. There are two approaches to cardinality â€“ one which compares sets directly using bijections and injections, and another which uses cardinal numbers."^^xsd:string ;
  rdfs:label "Cardinality Type"^^xsd:string ;
  rdfs:subClassOf qudt:EnumeratedValue ;
  owl:oneOf (
      qudt:CT_COUNTABLY-INFINITE
      qudt:CT_FINITE
    ) ;
  prov:wasInfluencedBy <http://en.wikipedia.org/wiki/Cardinal_number> ;
  prov:wasInfluencedBy <http://en.wikipedia.org/wiki/Cardinality> ;
.
qudt:CartesianCoordinates
  rdf:type owl:Class ;
  dc:description "A set of  variables which fix a geometric object. If the coordinates are distances measured along perpendicular axes, they are known as Cartesian coordinates."^^xsd:string ;
  vaem:description "A set of  variables which fix a geometric object. If the coordinates are distances measured along perpendicular axes, they are known as Cartesian coordinates."^^xsd:string ;
  rdfs:label "Cartesian Coordinate Type"^^xsd:string ;
  rdfs:subClassOf qudt:Coordinates ;
.
qudt:CharEncodingType
  rdf:type owl:Class ;
  dc:description "The class of all character encoding schemes, each of which defines a rule or algorithm for encoding character data as a sequence of bits or bytes."^^xsd:string ;
  rdfs:label "Char Encoding Type"^^xsd:string ;
  rdfs:subClassOf qudt:Encoding ;
.
qudt:CharacterType
  rdf:type owl:Class ;
  dc:description "A Character Type is a data type that defines the type and encoding of single characters."^^xsd:string ;
  rdfs:label "Character Type"^^xsd:string ;
  rdfs:subClassOf qudt:OrdinalType ;
.
qudt:Collection
  rdf:type owl:Class ;
  dc:description "A collection is a grouping of some variable number of zero or more data items that need to be operated upon together in some controlled fashion. Generally, the data items will all share the same data type or are derived from some common ancestor data type."^^xsd:string ;
  vaem:description "A collection is a grouping of some variable number of zero or more data items that need to be operated upon together in some controlled fashion. Generally, the data items will all share the same data type or are derived from some common ancestor data type."^^xsd:string ;
  rdfs:label "Collection Type"^^xsd:string ;
  rdfs:subClassOf qudt:AbstractDatatype ;
.
qudt:CompositeDatatype
  rdf:type owl:Class ;
  dc:description "Composite types are datatypes which can be constructed in a programming language out of that language's basic primitive types and other composite types. The act of constructing a composite type is known as composition."^^xsd:string ;
  vaem:description "Composite types are datatypes which can be constructed in a programming language out of that language's basic primitive types and other composite types. The act of constructing a composite type is known as composition."^^xsd:string ;
  rdfs:label "Composite Data Type"^^xsd:string ;
  rdfs:subClassOf qudt:StructuredDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:AlignmentType ;
      owl:onProperty qudt:alignment ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:PaddingType ;
      owl:onProperty qudt:padding ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:TypeList ;
      owl:onProperty qudt:elementTypeList ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:padding ;
    ] ;
.
qudt:CompositeTable
  rdf:type owl:Class ;
  rdfs:label "Composite Table Type"^^xsd:string ;
  rdfs:subClassOf qudt:Table ;
.
qudt:Container
  rdf:type owl:Class ;
  dc:description "A container is a class, a data structure, or an abstract data type (ADT) whose instances are collections of other objects. They are used to store objects in an organized way following specific access rules." ;
  vaem:description "A container is a class, a data structure, or an abstract data type (ADT) whose instances are collections of other objects. They are used to store objects in an organized way following specific access rules." ;
  rdfs:label "Container"^^xsd:string ;
  rdfs:subClassOf qudt:AbstractDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "1"^^xsd:int ;
      owl:onProperty qudt:elementTypeCount ;
    ] ;
  owl:equivalentClass qudt:Collection ;
.
qudt:CoordinateCenterType
  rdf:type owl:Class ;
  dc:description "An enumeration of coordinate centers for coordinate systems, such as \"Earth centered\", \"Mars centered\", \"Moon centered\", \"Sun centered\",  and \"Vehicle centered\"."^^xsd:string ;
  rdfs:label "Coordinate Center Type"^^xsd:string ;
  rdfs:subClassOf qudt:EnumeratedValue ;
  rdfs:subClassOf qudt:NominalScale ;
  owl:oneOf (
      <http://qudt.org/vocab/type/CC_MarsCentered>
      <http://qudt.org/vocab/type/CC_EarthCentered>
      <http://qudt.org/vocab/type/CC_MoonCentered>
      <http://qudt.org/vocab/type/CC_VehicleCentered>
      <http://qudt.org/vocab/type/CC_SunCentered>
    ) ;
  skos:prefLabel "Coordinate center"^^xsd:string ;
.
qudt:CoordinateMember
  rdf:type owl:Class ;
  vaem:description "A Coordinate Member Type is a data type that defines the properties of a coordinate in a coordinate system."^^xsd:string ;
  rdfs:label "Coordinate Member Type"^^xsd:string ;
  rdfs:subClassOf qudt:TupleMember ;
.
qudt:CoordinateSystem
  rdf:type owl:Class ;
  dc:description """In geometry, a coordinate system is a system which uses one or more numbers, or coordinates, to uniquely determine the position of a point or other geometric element on a manifold such as Euclidean space. The order of the coordinates is significant and they are sometimes identified by their position in an ordered tuple and sometimes by a letter, as in 'the x-coordinate'. 

In elementary mathematics the coordinates are taken to be real numbers, but may be complex numbers or elements of a more abstract system such as a commutative ring. The use of a coordinate system allows problems in geometry to be translated into problems about numbers and vice versa; this is the basis of analytic geometry. 

In astronomy, a celestial coordinate system is a system for specifying positions of celestial objects: satellites, planets, stars, galaxies, and so on. Coordinate systems can specify a position in 3-dimensional space, or merely the direction of the object on the celestial sphere, if its distance is not known or not important.

The coordinate systems are implemented in either spherical coordinates or rectangular coordinates. Spherical coordinates, projected on the celestial sphere, are analogous to the geographic coordinate system used on the surface of the Earth. These differ in their choice of fundamental plane, which divides the celestial sphere into two equal hemispheres along a great circle. Rectangular coordinates, in appropriate units, are simply the cartesian equivalent of the spherical coordinates, with the same fundamental (x,y) plane and primary (x-axis) direction. Each coordinate system is named for its choice of fundamental plane."""^^xsd:string ;
  rdfs:label "Coordinate system"^^xsd:string ;
  rdfs:seeAlso <http://en.wikipedia.org/wiki/Astronomical_coordinate_systems> ;
  rdfs:seeAlso <http://en.wikipedia.org/wiki/Coordinate_system> ;
  rdfs:seeAlso <http://mathworld.wolfram.com/CoordinateSystem.html> ;
  rdfs:seeAlso <http://mathworld.wolfram.com/Coordinates.html> ;
  rdfs:subClassOf qudt:Concept ;
  rdfs:subClassOf skos:Concept ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:ReferenceFrame ;
      owl:onProperty qudt:referenceFrame ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:referenceFrame ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:abbreviation ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:coordinateCenter ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty vaem:acronym ;
    ] ;
  owl:sameAs <http://dbpedia.org/resource/Coordinate_system> ;
.
qudt:CoordinateSystemFrame
  rdf:type owl:Class ;
  rdfs:label "Coordinate system frame"^^xsd:string ;
  rdfs:subClassOf skos:Concept ;
.
qudt:CoordinateSystemType
  rdf:type owl:Class ;
  dc:description "The primary attributes of any coordinate system are the coordinate frame or orientation of the axes of the coordinate system and the coordinate center or origin of the coordinate system. The coordinate center is the easier of the two attributes to define and in trajectory-related coordinate systems is often taken to be the center of mass of natural solar system bodies such as the Earth, the Moon, or Mars. Precise definition of the coordinate frame, however, usually takes much more effort. As a result, the primary purpose of this section is to provide a detailed description of a number of different coordinate frames commonly used in lunar and Mars mission analysis. All of the coordinate frames described in this section are standard, right-handed coordinate frames with orthogonal axes at the origin. In general, the coordinate frame and the coordinate center are independent quantities. In other words, multiple coordinate systems can be defined using the same coordinate center (with different frames) or the same coordinate frame (with different centers). "^^xsd:string ;
  rdfs:label "Coordinate system type"^^xsd:string ;
  rdfs:subClassOf qudt:EnumeratedValue ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:originDefinition ;
    ] ;
.
qudt:Coordinates
  rdf:type owl:Class ;
  dc:description "A coordinate system is a mathematical structure for assigning a unique n-tuple of numbers or scalars to each point in an n-dimensional space. A Coordinate System Type is a data type that defines the properties of data structures that represent coordinate systems."^^xsd:string ;
  vaem:description "A coordinate system is a mathematical structure for assigning a unique n-tuple of numbers or scalars to each point in an n-dimensional space. A Coordinate System Type is a data type that defines the properties of data structures that represent coordinate systems."^^xsd:string ;
  rdfs:label "Coordinate System Type"^^xsd:string ;
  rdfs:subClassOf qudt:Tuple ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:CoordinateMember ;
      owl:onProperty qudt:elementType ;
    ] ;
.
qudt:Coordinates-2D
  rdf:type owl:Class ;
  dc:description "A 2D coordinate system is a system for assigning a two-tuple of numbers or scalars to each point in an 2-dimensional space. A 2D Coordinate Type is a data type that defines the data type for each coordinate (tuple member) in a 2D coordinate system."^^xsd:string ;
  vaem:description "A 2D coordinate system is a system for assigning a two-tuple of numbers or scalars to each point in an 2-dimensional space. A 2D Coordinate Type is a data type that defines the data type for each coordinate (tuple member) in a 2D coordinate system."^^xsd:string ;
  rdfs:label "2D Coordinate Type"^^xsd:string ;
  rdfs:subClassOf qudt:CartesianCoordinates ;
  rdfs:subClassOf qudt:Two-Tuple ;
.
qudt:Coordinates-2D-DoublePrecision
  rdf:type owl:Class ;
  dc:description "2D coordinates in double floating point precision for locating a point in physical space" ;
  vaem:description "2D coordinates in double floating point precision for locating a point in physical space" ;
  rdfs:label "Coordinates-2D-Double precision"^^xsd:string ;
  rdfs:subClassOf qudt:Coordinates-2D ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom xsd:double ;
      owl:onProperty <http://qudt.org/schema/type#Double_X> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom xsd:double ;
      owl:onProperty <http://qudt.org/schema/type#Double_Y> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#Double_X> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#Double_Y> ;
    ] ;
.
qudt:Coordinates-2D-SinglePrecision
  rdf:type owl:Class ;
  dc:description "2D coordinates in single floating point precision for locating a point in physical space"^^xsd:string ;
  vaem:description "2D coordinates in single floating point precision for locating a point in physical space"^^xsd:string ;
  rdfs:label "Cartesian Coordinates 2D Single Precision"^^xsd:string ;
  rdfs:subClassOf qudt:Coordinates-2D ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom xsd:float ;
      owl:onProperty qudt:float_X ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom xsd:float ;
      owl:onProperty qudt:float_Y ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:float_X ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:float_Y ;
    ] ;
.
qudt:Coordinates-3D
  rdf:type owl:Class ;
  dc:description "A 3D coordinate system is a system for assigning a three-tuple of numbers or scalars to each point in an 3-dimensional space. A 3D Coordinate Type is a data type that defines the data type for each coordinate (tuple member) in a 3D coordinate system."^^xsd:string ;
  vaem:description "A 3D coordinate system is a system for assigning a three-tuple of numbers or scalars to each point in an 3-dimensional space. A 3D Coordinate Type is a data type that defines the data type for each coordinate (tuple member) in a 3D coordinate system."^^xsd:string ;
  rdfs:label "3D Coordinate Type"^^xsd:string ;
  rdfs:subClassOf qudt:CartesianCoordinates ;
  rdfs:subClassOf qudt:Three-Tuple ;
.
qudt:Coordinates-3D-DoublePrecision
  rdf:type owl:Class ;
  dc:description "3D coordinates in double floating point precision for locating a point in physical space"^^xsd:string ;
  vaem:description "3D coordinates in double floating point precision for locating a point in physical space"^^xsd:string ;
  rdfs:label "3D Coordinates (Double Precision)"^^xsd:string ;
  rdfs:subClassOf qudt:Coordinates-3D ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom xsd:double ;
      owl:onProperty <http://qudt.org/schema/type#Double_X> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom xsd:double ;
      owl:onProperty <http://qudt.org/schema/type#Double_Y> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom xsd:double ;
      owl:onProperty <http://qudt.org/schema/type#Double_Z> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#Double_X> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#Double_Y> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#Double_Z> ;
    ] ;
.
qudt:Coordinates-3D-SinglePrecision
  rdf:type owl:Class ;
  dc:description "3D coordinates in single floating point precision for locating a point in physical space" ;
  vaem:description "3D coordinates in single floating point precision for locating a point in physical space" ;
  rdfs:label "3D Coordinates (Single Precision)"^^xsd:string ;
  rdfs:subClassOf qudt:Coordinates-3D ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom xsd:float ;
      owl:onProperty qudt:float_X ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom xsd:float ;
      owl:onProperty qudt:float_Y ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom xsd:float ;
      owl:onProperty qudt:float_Z ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:float_X ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:float_Y ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:float_Z ;
    ] ;
.
qudt:Datatype
  rdf:type owl:Class ;
  dc:description "A data type is a definition of a set of values (for example, \"all integers between 0 and 10\"), and the allowable operations on those values; the meaning of the data; and the way values of that type can be stored. Some types are primitive - built-in to the language, with no visible internal structure - e.g. Boolean; others are composite - constructed from one or more other types (of either kind) - e.g. lists, arrays, structures, unions. Object-oriented programming extends this with classes which encapsulate both the structure of a type and the operations that can be performed on it. Some languages provide strong typing, others allow implicit type conversion and/or explicit type conversion."^^xsd:string ;
  rdfs:subClassOf qudt:Concept ;
  rdfs:subClassOf skos:Concept ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:CardinalityType ;
      owl:onProperty qudt:cardinality ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:Datatype ;
      owl:onProperty qudt:basis ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:OrderedType ;
      owl:onProperty qudt:orderedType ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom xsd:string ;
      owl:onProperty qudt:designator ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:bounded ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:cardinality ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:orderedType ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:basis ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty vaem:description ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:minCardinality "0"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:cName ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:minCardinality "0"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:javaName ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:minCardinality "0"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:jsName ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:minCardinality "0"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:matlabName ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:minCardinality "0"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:pythonName ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:minCardinality "0"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:vbName ;
    ] ;
  prov:wasInfluencedBy <http://en.wikipedia.org/wiki/Data_type> ;
  prov:wasInfluencedBy <http://foldoc.org/data+type> ;
  prov:wasInfluencedBy <http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Data_type.html> ;
.
qudt:DateStringType
  rdf:type owl:Class ;
  dc:description "Date String Types are scalar data types that define the properties of strings that represent calendar dates."^^xsd:string ;
  vaem:description "Date types are scalar data types that define the properties of data structures that represent calendar dates."^^xsd:string ;
  rdfs:label "Date String Type"^^xsd:string ;
  rdfs:subClassOf qudt:DateTimeStringType ;
.
qudt:DateTimeStringEncodingType
  rdf:type owl:Class ;
  vaem:description "Date Time encodings are logical encodings for expressing date/time quantities as strings by applying unambiguous formatting and parsing rules."^^xsd:string ;
  rdfs:label "Date Time String Encoding Type"^^xsd:string ;
  rdfs:subClassOf qudt:StringEncodingType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onDataRange xsd:string ;
      owl:onProperty qudt:allowedPattern ;
    ] ;
.
qudt:DateTimeStringType
  rdf:type owl:Class ;
  vaem:description "A class of data types for structures that represent temporal quantities. I.e. calendar dates, times, duration of time since a given epoch, etc."^^xsd:string ;
  rdfs:label "Temporal Type"^^xsd:string ;
  rdfs:subClassOf qudt:StringType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:DateTimeStringEncodingType ;
      owl:onProperty qudt:encoding ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:encoding ;
    ] ;
.
qudt:Dictionary
  rdf:type owl:Class ;
  dc:description "A \"Map\"."^^xsd:string ;
  vaem:description "A \"Map\"."^^xsd:string ;
  rdfs:label "Dictionary Type"^^xsd:string ;
  rdfs:subClassOf qudt:Map ;
.
qudt:DimensionVector
  rdf:type owl:Class ;
  rdfs:label "Dimension Vector"^^xsd:string ;
  rdfs:subClassOf skos:Concept ;
.
qudt:DimensionalDatatype
  rdf:type owl:Class ;
  dc:description "A dimensional data type is a data type that specifies a physical quantity or unit of measure. Information about the physical dimensions of the quantities and units is embedded in their types."^^xsd:string ;
  rdfs:label "Dimensional Data Type"^^xsd:string ;
  rdfs:subClassOf qudt:StructuredDatatype ;
.
qudt:DiscreteStateEnumeration
  rdf:type owl:Class ;
  dc:description "A discrete state enumeration is a set of discrete values that characterize a boolean variable, measurement or controlled variable. Examples of discrete state enumerations are 'BooleanEnumeration' whose values are 'true' and 'false', 'OnOffEnumeration' whose values are 'on' and 'off', and 'WetDryEnumeration' whose values are 'wet' and 'dry'." ;
  vaem:description "A discrete state enumeration is a set of discrete values that characterize a boolean variable, measurement or controlled variable. Examples of discrete state enumerations are 'BooleanEnumeration' whose values are 'true' and 'false', 'OnOffEnumeration' whose values are 'on' and 'off', and 'WetDryEnumeration' whose values are 'wet' and 'dry'." ;
  rdfs:label "Discrete State Enumeration"^^xsd:string ;
  rdfs:subClassOf qudt:Enumeration ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:inverted ;
    ] ;
.
qudt:DoublePrecisionType
  rdf:type owl:Class ;
  dc:description "A double precision data type specifies how a numeric value, such as an integer or real number, is stored in memory that occupies two words in computer memory, where the byte length of a word depends on machine address size of the computer processor. For example, on 32-bit machine architectures, a word is four bytes, and so double precision data value on a 32-bit machine architecture occupies eight bytes of memory."^^xsd:string ;
  vaem:description "A double precision data type specifies how a numeric value, such as an integer or real number, is stored in memory that occupies two words in computer memory, where the byte length of a word depends on machine address size of the computer processor. For example, on 32-bit machine architectures, a word is four bytes, and so double precision data value on a 32-bit machine architecture occupies eight bytes of memory."^^xsd:string ;
  rdfs:label "Double Precision Type"^^xsd:string ;
  rdfs:subClassOf qudt:NumericType ;
  owl:disjointWith qudt:SinglePrecisionType ;
.
qudt:EarthCoordinateSystem
  rdf:type owl:Class ;
  dc:description "A\"Trajectory Coordinate System\" for all earth-centered coordinates, such as \"Earth mean equator and prime meridian coordinate system\", \"Earth true equator and prime meridian of epoch coordinate system\", \"International celestial reference system\", \"International terrestrial reference system\", \"Sun centered international celestial reference system\", \"Vehicle centered international celestial reference system\"."^^xsd:string ;
  rdfs:label "Earth Coordinate System Type"^^xsd:string ;
  rdfs:subClassOf qudt:TrajectoryCoordinateSystem ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue <http://qudt.org/vocab/type/CC_EarthCentered> ;
      owl:onProperty qudt:coordinateCenter ;
    ] ;
.
qudt:Encoding
  rdf:type owl:Class ;
  dc:description "An encoding is a rule or algorithm that is used to convert data from a native, or unspecified form into a specific form that satisfies the encoding rules. Examples of encodings include character encodings, such as UTF-8."^^xsd:string ;
  rdfs:label "Encoding"^^xsd:string ;
  rdfs:subClassOf skos:Concept ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:bytes ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:bits ;
    ] ;
.
qudt:EndianType
  rdf:type owl:Class ;
  dc:description """In computing, endianness is the ordering used to represent some kind of data as a sequence of smaller units. Typical cases are the order in which integer values are stored as bytes in computer memory (relative to a given memory addressing scheme) and the transmission order over a network or other medium. When specifically talking about bytes, endianness is also referred to simply as byte order. 

Most computer processors simply store integers as sequences of bytes, so that, conceptually, the encoded value can be obtained by simple concatenation. For an $n-byte$ integer value this allows $n!$ (n factorial) possible representations (one for each byte permutation). The two most common of them are: increasing numeric significance with increasing memory addresses, known as little-endian, and its opposite, called big-endian."""^^xsd:string ;
  rdfs:label "Endian Type"^^xsd:string ;
  rdfs:subClassOf qudt:EnumeratedValue ;
  owl:oneOf (
      <http://qudt.org/vocab/type/LittleEndian>
      <http://qudt.org/vocab/type/BigEndian>
    ) ;
  prov:wasInfluencedBy <http://en.wikipedia.org/wiki/Endianness> ;
.
qudt:EngineeringValueTupleMember
  rdf:type owl:Class ;
  rdfs:label "Engineering Value Tuple Member"^^xsd:string ;
  rdfs:subClassOf qudt:TupleMember ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:RealSinglePrecisionType ;
      owl:onProperty qudt:elementType ;
    ] ;
  owl:disjointWith qudt:RawValueTupleMember ;
  owl:equivalentClass [
      rdf:type owl:Class ;
      owl:intersectionOf (
          qudt:TupleMember
          [
            rdf:type owl:Restriction ;
            owl:allValuesFrom qudt:RealSinglePrecisionType ;
            owl:onProperty qudt:elementType ;
          ]
        ) ;
    ] ;
.
qudt:EnumeratedValue
  rdf:type owl:Class ;
  rdfs:subClassOf qudt:Datatype ;
.
qudt:Enumeration
  rdf:type owl:Class ;
  rdfs:label "Enumeration"^^xsd:string ;
  rdfs:subClassOf qudt:StructuredDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      dc:description "The number of bits allocated to the field for encoding any tags associated with elements."^^xsd:string ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:bits ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:EnumeratedValue ;
      owl:onProperty qudt:defaultValue ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:EnumeratedValue ;
      owl:onProperty dtype:value ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:encoding ;
    ] ;
.
qudt:FieldType
  rdf:type owl:Class ;
  rdfs:subClassOf qudt:CompositeDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:Datatype ;
      owl:onProperty qudt:elementType ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:fieldName ;
    ] ;
.
qudt:FileFormat
  rdf:type owl:Class ;
  rdfs:label "File format"^^xsd:string ;
  rdfs:subClassOf qudt:EnumeratedValue ;
.
qudt:FixedIntervalTimeSeriesArray
  rdf:type owl:Class ;
  dc:description "A Fixed Interval Time Series Array Type is a data type that specifies the properties of arrays that hold time series data that has been sampled over uniformly spaced time intervals. A time series is a sequence of data points, measured typically at successive times, spaced at uniform or non-uniform time intervals."^^xsd:string ;
  vaem:description "A Fixed Interval Time Series Array Type is a data type that specifies the properties of arrays that hold time series data that has been sampled over uniformly spaced time intervals. A time series is a sequence of data points, measured typically at successive times, spaced at uniform or non-uniform time intervals."^^xsd:string ;
  rdfs:label "Fixed Interval Time Series Array Type"^^xsd:string ;
  rdfs:subClassOf qudt:TimeSeriesArray ;
.
qudt:FloatingPointEncodingType
  rdf:type owl:Class ;
  dc:description "A \"Encoding\" with the following instance(s): \"Double Precision Encoding\", \"Single Precision Real Encoding\"."^^xsd:string ;
  rdfs:label "Floating Point Encoding"^^xsd:string ;
  rdfs:subClassOf qudt:Encoding ;
.
qudt:FrameType
  rdf:type owl:Class ;
  dc:description "This class contains elements which specify the intertial type of a coordinate frame as either inertial, rotating, or non-rotating."^^xsd:string ;
  rdfs:label "Frame Type"^^xsd:string ;
  rdfs:subClassOf qudt:EnumeratedValue ;
  owl:oneOf (
      <http://qudt.org/vocab/type/FT_ROTATING>
      <http://qudt.org/vocab/type/FT_NON-ROTATING>
      <http://qudt.org/vocab/type/FT_INERTIAL>
    ) ;
.
qudt:FunctionDatatype
  rdf:type owl:Class ;
  dc:description "A function data type defines the input and output data type for a function or method. It includes at least the function name and the number of its parameters. In some programming languages, it may also specify the function's return type or the types of its arguments."^^xsd:string ;
  vaem:description "A function data type defines the inputs and outputs for a function or method. It includes at least the function name and the number of its parameters. In some programming languages, it may also specify the function's return type or the types of its arguments. [Wikipedia]"^^xsd:string ;
  rdfs:label "Function Data Type"^^xsd:string ;
  rdfs:subClassOf qudt:StructuredDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:Datatype ;
      owl:onProperty qudt:argType ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:Datatype ;
      owl:onProperty qudt:returnType ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:functionArity ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:returnType ;
    ] ;
.
qudt:Graph
  rdf:type owl:Class ;
  dc:description "A graph is a kind of abstract data type, that consists of a set of nodes (also called vertices) and a set of edges that establish relationships (connections) between the nodes. A Graph Type is a data type that defines the properties of data structures that represent graphs and their members (nodes and edges)."^^xsd:string ;
  vaem:description "A graph is a kind of abstract data type, that consists of a set of nodes (also called vertices) and a set of edges that establish relationships (connections) between the nodes. A Graph Type is a data type that defines the properties of data structures that represent graphs and their members (nodes and edges)."^^xsd:string ;
  rdfs:label "Graph Type"^^xsd:string ;
  rdfs:subClassOf qudt:Collection ;
.
qudt:GroundCoordinateSystem
  rdf:type owl:Class ;
  rdfs:label "Ground coordinate system"^^xsd:string ;
  rdfs:subClassOf qudt:AerospaceCoordinateSystem ;
.
qudt:HashTable
  rdf:type owl:Class ;
  dc:description "A hash table is a kind of map that utilizes a hash function to perform efficient lookup: given a key (e.g., a person's name), find the corresponding value (e.g., that person's telephone number). Hash tables support the efficient lookup, insertion and deletion of elements in constant time on average. A Hash Table Type is a data type that defines the types of a hash table's key-value pairs."^^xsd:string ;
  vaem:description "A hash table is a kind of map that utilizes a hash function to perform efficient lookup: given a key (e.g., a person's name), find the corresponding value (e.g., that person's telephone number). Hash tables support the efficient lookup, insertion and deletion of elements in constant time on average. A Hash Table Type is a data type that defines the types of a hash table's key-value pairs."^^xsd:string ;
  rdfs:label "Hash Table Type"^^xsd:string ;
  rdfs:subClassOf qudt:Map ;
.
qudt:Heap
  rdf:type owl:Class ;
  dc:description "A heap is a specialized tree-based data structure that satisfies the condition: if B is a child node of A, then $key(A) \\ge key(B)$. This implies that an element with the greatest key is always in the root node, and so such a heap is sometimes called a max heap. Alternatively, if the comparison is reversed, the smallest element is always in the root node, which results in a min heap. The function or method that implements the key() operator is specified by the heap type."^^xsd:string ;
  rdfs:label "Heap Type"^^xsd:string ;
  rdfs:subClassOf qudt:OrderedTree ;
.
qudt:HexBinaryType
  rdf:type owl:Class ;
  dc:description "A \"Scalar Datatype\"."^^xsd:string ;
  vaem:description "A \"Scalar Datatype\"."^^xsd:string ;
  rdfs:label "Hexidecimal Binary Type"^^xsd:string ;
  rdfs:subClassOf qudt:TextStringType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:length ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:maxLength ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:minLength ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:pattern ;
    ] ;
.
qudt:IconicCueEnumeration
  rdf:type owl:Class ;
  rdfs:label "Iconic Cue Enumeration"^^xsd:string ;
  rdfs:subClassOf qudt:ModalEnumeration ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom <http://qudt.org/schema/type#IconicCue> ;
      owl:onProperty qudt:defaultValue ;
    ] ;
  owl:disjointWith qudt:AuralCueEnumeration ;
  owl:disjointWith qudt:KinestheticCueEnumeration ;
  owl:disjointWith qudt:VisualCueEnumeration ;
.
qudt:InertialCoordinateFrame
  rdf:type owl:Class ;
  dc:description "A \"Coordinate Frame\"."^^xsd:string ;
  rdfs:label "Inertial Coordinate Frame"^^xsd:string ;
  rdfs:subClassOf qudt:InertialReferenceFrame ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue <http://qudt.org/vocab/type/FT_NON-ROTATING> ;
      owl:onProperty qudt:frameType ;
    ] ;
  owl:equivalentClass qudt:NonRotatingInertialFrame ;
.
qudt:InertialReferenceFrame
  rdf:type owl:Class ;
  rdfs:label "Inertial reference frame"^^xsd:string ;
  rdfs:subClassOf qudt:ReferenceFrame ;
.
qudt:IntegerDatatype
  rdf:type owl:Class ;
  dc:description "An Integer Type is a data type that specifies how integer numbers are represented and stored in machine memory."^^xsd:string ;
  rdfs:label "Integer Datatype"^^xsd:string ;
  rdfs:subClassOf qudt:NumericType ;
  rdfs:subClassOf qudt:OrdinalType ;
.
qudt:IntegerEncodingType
  rdf:type owl:Class ;
  dc:description "The encoding scheme for integer types"^^xsd:string ;
  rdfs:label "Integer Encoding"^^xsd:string ;
  rdfs:subClassOf qudt:Encoding ;
.
qudt:InterpolatedTable
  rdf:type owl:Class ;
  rdfs:label "Interpolated Table Type"^^xsd:string ;
  rdfs:subClassOf qudt:Table ;
.
qudt:KinestheticCueEnumeration
  rdf:type owl:Class ;
  rdfs:label "Kinesthetic Cue Enumeration"^^xsd:string ;
  rdfs:subClassOf qudt:ModalEnumeration ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom <http://qudt.org/schema/type#KinestheticCue> ;
      owl:onProperty qudt:defaultValue ;
    ] ;
  owl:disjointWith qudt:AuralCueEnumeration ;
  owl:disjointWith qudt:IconicCueEnumeration ;
  owl:disjointWith qudt:VisualCueEnumeration ;
.
qudt:List
  rdf:type owl:Class ;
  rdfs:label "List"^^xsd:string ;
  rdfs:subClassOf qudt:Collection ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:Datatype ;
      owl:onProperty rdf:first ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:List ;
      owl:onProperty rdf:rest ;
    ] ;
.
qudt:LocalCoordinateSystem
  rdf:type owl:Class ;
  dc:description "A \"Trajectory Coordinate System\" with the following instance(s): \"Local vertical curvilinear coordinate system\", \"Local vertical local horizontal coordinate system\", \"Vehicle centered local vertical curvilinear coordinate system\"."^^xsd:string ;
  rdfs:label "Local Coordinate System Type"^^xsd:string ;
  rdfs:subClassOf qudt:TrajectoryCoordinateSystem ;
.
qudt:LongIntegerType
  rdf:type owl:Class ;
  vaem:description "A Long Integer is an integer that can be represented in four octets (32 bits) of machine memory. Long integers may be signed or unsigned."^^xsd:string ;
  rdfs:label "Long Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:IntegerDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "32"^^xsd:int ;
      owl:onProperty qudt:bits ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "4"^^xsd:int ;
      owl:onProperty qudt:octets ;
    ] ;
.
qudt:LunarCoordinateSystem
  rdf:type owl:Class ;
  dc:description "Two slightly different coordinate frames are commonly used to define the orientation of the axes of a lunar body-fixed coordinate system: a mean Earth/rotation frame and a principal axis coordinate frame. The mean Earth/rotation frame (sometimes called the \"Mean Earth/polar axis\" frame) is a lunar body-fixed coordinate frame with the X-axis aligned with the mean direction from the Moon to the Earth and the Z-axis aligned with the mean axis of rotation of the Moon. The principal axis frame is a lunar body-fixed coordinate frame aligned with the principal axes of the Moon. Due to the fact that the Moon is synchronously rotating but is not exactly symmetric, the principal axes and the mean Earth/rotation axes of the Moon do not coincide." ;
  rdfs:label "Lunar Coordinate System"^^xsd:string ;
  rdfs:subClassOf qudt:TrajectoryCoordinateSystem ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:realization ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:xAxisDefinition ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:yAxisDefinition ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:zAxisDefinition ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue <http://qudt.org/vocab/type/CC_MoonCentered> ;
      owl:onProperty qudt:coordinateCenter ;
    ] ;
.
qudt:MajorMinorType
  rdf:type owl:Class ;
  rdfs:label "Major minor type"^^xsd:string ;
  rdfs:subClassOf qudt:EnumeratedValue ;
  owl:oneOf (
      <http://qudt.org/vocab/type/Minor>
      <http://qudt.org/vocab/type/Major>
    ) ;
.
qudt:Map
  rdf:type owl:Class ;
  dc:description "A Map Type is an abstract data type that defines the properties of map data structures. A Map (or Associative Array) is an abstract data structure composed of a collection of keys and a collection of values, where each key is associated with one value. The operation of finding the value associated with a key is called a lookup or indexing, and this is the most important operation supported by an associative array. The relationship between a key and its value is sometimes called a mapping or binding."^^xsd:string ;
  vaem:description "A Map Type is an abstract data type that defines the properties of map data structures. A Map (or Associative Array) is an abstract data structure composed of a collection of keys and a collection of values, where each key is associated with one value. The operation of finding the value associated with a key is called a lookup or indexing, and this is the most important operation supported by an associative array. The relationship between a key and its value is sometimes called a mapping or binding."^^xsd:string ;
  rdfs:label "Map Type"^^xsd:string ;
  rdfs:subClassOf qudt:Collection ;
  owl:equivalentClass qudt:AssociativeArray ;
.
qudt:MarsCoordinateSystem
  rdf:type owl:Class ;
  dc:description "A \"Trajectory Coordinate System\" with the following instance(s): \"Mars mean equator and IAU-Node of epoch\", \"Mars mean equator and prime meridian body-fixed\"."^^xsd:string ;
  rdfs:label "Mars Coordinate System Type"^^xsd:string ;
  rdfs:subClassOf qudt:TrajectoryCoordinateSystem ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue <http://qudt.org/vocab/type/CC_MarsCentered> ;
      owl:onProperty qudt:coordinateCenter ;
    ] ;
.
qudt:MassPropertiesArray
  rdf:type owl:Class ;
  dc:description "The Mass Properties of an object are its: Center of Gravity, Mass, Moment of Inertia, and Product of Inertia. A mass properties array is an array whose elements contain these measured quantities for some object. A mass properties array data type provides the type specification for a class of arrays in which the data types of the elements are constrained to be one of these four properties."^^xsd:string ;
  vaem:description "The Mass Properties of an object are its: Center of Gravity, Mass, Moment of Inertia, and Product of Inertia. A mass properties array is an array whose elements contain these measured quantities for some object. A mass properties array data type provides the type specification for a class of arrays in which the data types of the elements are constrained to be one of these four properties."^^xsd:string ;
  rdfs:label "Mass Properties Array Type"^^xsd:string ;
  rdfs:subClassOf qudt:Array ;
.
qudt:Matrix
  rdf:type owl:Class ;
  dc:description "A Matrix Type is a data type that specifies the properties of data structures that hold matricies."^^xsd:string ;
  vaem:description "A Matrix Type is a data type that specifies the properties of data structures that hold matricies."^^xsd:string ;
  rdfs:label "Matrix Type"^^xsd:string ;
  rdfs:subClassOf qudt:MultiDimensionalArray ;
.
qudt:MemoryOrderType
  rdf:type owl:Class ;
  rdfs:label "Memory order type"^^xsd:string ;
  rdfs:subClassOf qudt:EnumeratedValue ;
  owl:oneOf (
      <http://qudt.org/vocab/type/HighToLow>
      <http://qudt.org/vocab/type/LowToHigh>
    ) ;
.
qudt:ModalEnumeration
  rdf:type owl:Class ;
  rdfs:label "Modal Enumeration"^^xsd:string ;
  rdfs:subClassOf qudt:Enumeration ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom <http://qudt.org/schema/type#ModalCue> ;
      owl:onProperty qudt:defaultValue ;
    ] ;
  owl:equivalentClass [
      rdf:type owl:Class ;
      owl:unionOf (
          qudt:AuralCueEnumeration
          qudt:IconicCueEnumeration
          qudt:KinestheticCueEnumeration
          qudt:VisualCueEnumeration
        ) ;
    ] ;
.
qudt:MultiDimensionalArray
  rdf:type owl:Class ;
  dc:description "Ordinary or one-dimensional arrays are indexed by a single integer. For a multi-dimensional array, the index into the array uses an ordered list of integers, such as in a[3,1,5]. The length of the list of integers used to index into the multi-dimensional array is always the same and is referred to as the array's dimensionality. The bounds on each of these are called the array's dimensions."^^xsd:string ;
  vaem:description "Ordinary or one-dimensional arrays are indexed by a single integer. For a multi-dimensional array, the index into the array uses an ordered list of integers, such as in a[3,1,5]. The length of the list of integers used to index into the multi-dimensional array is always the same and is referred to as the array's dimensionality. The bounds on each of these are called the array's dimensions."^^xsd:string ;
  rdfs:label "Multi Dimensional Array Type"^^xsd:string ;
  rdfs:subClassOf qudt:Array ;
.
qudt:MultiDimensionalDataFormat
  rdf:type owl:Class ;
  dc:description "Data formats for storing and manipulating scalar and multidimensional data in a platform and discipline independent manner, for example HDF, CDF and netCDF." ;
  vaem:description "Data formats for storing and manipulating scalar and multidimensional data in a platform and discipline independent manner, for example HDF, CDF and netCDF." ;
  rdfs:label "Multi Dimensional Data Format"^^xsd:string ;
  rdfs:subClassOf qudt:CompositeDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#descriptor> ;
    ] ;
.
qudt:MultiModalEnumeration
  rdf:type owl:Class ;
  rdfs:label "Multi modal enumeration"^^xsd:string ;
  rdfs:subClassOf qudt:Enumeration ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:ModalEnumeration ;
      owl:onProperty <http://qudt.org/schema/type#modalCueEnumeration> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#auralCueEnumeration> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#iconicCueEnumeration> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#kinestheticCueEnumeration> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#visualCueEnumeration> ;
    ] ;
.
qudt:MultiModalType
  rdf:type owl:Class ;
  rdfs:label "Multi Modal Type"^^xsd:string ;
  rdfs:subClassOf qudt:EnumeratedValue ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom <http://qudt.org/schema/type#ModalCue> ;
      owl:onProperty <http://qudt.org/schema/type#modalCue> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#auralCue> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#iconicCue> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#kinestheticCue> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#visualCue> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:onProperty <http://qudt.org/schema/type#modalCue> ;
      owl:someValuesFrom <http://qudt.org/schema/type#ModalCue> ;
    ] ;
.
qudt:N-Tuple
  rdf:type owl:Class ;
  dc:description "A tuple containing n objects is known as an \"n-tuple\". For example the 4-tuple (or \"quadruple\"), with components of respective types PERSON, DAY, MONTH and YEAR, could be used to record that a certain person was born on a certain day of a certain month of a certain year." ;
  vaem:description "A tuple containing n objects is known as an \"n-tuple\". For example the 4-tuple (or \"quadruple\"), with components of respective types PERSON, DAY, MONTH and YEAR, could be used to record that a certain person was born on a certain day of a certain month of a certain year." ;
  rdfs:label "N-Tuple Type"^^xsd:string ;
  rdfs:subClassOf qudt:Tuple ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:minCardinality "1"^^xsd:int ;
      owl:onProperty qudt:elementType ;
    ] ;
.
qudt:NonRotatingInertialFrame
  rdf:type owl:Class ;
  dc:description "The non-rotating (or \"inertial\") coordinate frames are defined by taking a \"snapshot\" of the orientation of a particular set of right-handed, orthogonal axes at a specific epoch or time. In other words, the non-rotating coordinate frame, however it is defined, is frozen or fixed at a specific time - for all time. These non-rotating coordinate frames are referred to as \"of Epoch\" coordinate frames." ;
  rdfs:label "Non Rotating Coordinate Frame"^^xsd:string ;
  rdfs:subClassOf qudt:InertialReferenceFrame ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue <http://qudt.org/vocab/type/FT_NON-ROTATING> ;
      owl:onProperty qudt:frameType ;
    ] ;
  owl:equivalentClass qudt:InertialCoordinateFrame ;
.
qudt:NumericType
  rdf:type owl:Class ;
  dc:description "Numeric data types are data types whose values denote quantities (in some mathematical number system)."^^xsd:string ;
  vaem:description "Numeric data types are data types whose values denote quantities (in some mathematical number system)."^^xsd:string ;
  rdfs:label "Numeric Type"^^xsd:string ;
  rdfs:subClassOf qudt:ScalarDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:SignednessType ;
      owl:onProperty qudt:signedness ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:accuracy ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:signedness ;
    ] ;
.
qudt:OctetType
  rdf:type owl:Class ;
  dc:description "An 8 bit unsigned integer" ;
  vaem:description "An 8 bit unsigned integer" ;
  rdfs:label "Octet Type"^^xsd:string ;
  rdfs:subClassOf qudt:UnsignedIntegerType ;
.
qudt:OrderedCollection
  rdf:type owl:Class ;
  dc:description "An Ordered Collection Type is an abstract data type that defines the properties of collection data structures whose members can be linearly ordered. An ordered collection is a collection together with an ordering relation (such as greater than) that linearly orders the collection elements."^^xsd:string ;
  vaem:description "An Ordered Collection Type is an abstract data type that defines the properties of collection data structures whose members can be linearly ordered. An ordered collection is a collection together with an ordering relation (such as greater than) that linearly orders the collection elements."^^xsd:string ;
  rdfs:label "Ordered Collection Type"^^xsd:string ;
  rdfs:subClassOf qudt:Collection ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:Datatype ;
      owl:onProperty rdf:first ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:OrderedCollection ;
      owl:onProperty rdf:rest ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom dtype:ComparisonOperator ;
      owl:onProperty qudt:orderingRelation ;
    ] ;
.
qudt:OrderedTree
  rdf:type owl:Class ;
  dc:description "An \\textit{Ordered Tree Type} is a data type that defines the properties of data structures that represent ordered trees. An ordered tree is a tree where the children of every node are ordered, that is, there is a first child, second child, third child, etc. Typically a type specification for an ordered tree will include the comparison operator (such as $\\lt$ or $\\gt$) that is used to order the nodes."^^xsd:string ;
  rdfs:label "Ordered Tree Type"^^xsd:string ;
  rdfs:subClassOf qudt:OrderedCollection ;
  rdfs:subClassOf qudt:Tree ;
.
qudt:OrderedType
  rdf:type owl:Class ;
  dc:description "Describes how a data or information structure is ordered."^^xsd:string ;
  rdfs:label "Ordered type"^^xsd:string ;
  rdfs:subClassOf qudt:EnumeratedValue ;
  owl:oneOf (
      qudt:Unordered
      qudt:PartiallyOrdered
      qudt:TotallyOrdered
    ) ;
.
qudt:OrdinalType
  rdf:type owl:Class ;
  dc:description "An ordinal data type is a data type that specifies the properties of values that can easily be put in a one to one correspondence with a subset of the natural numbers. Examples include boolean, character, and integer data types."^^xsd:string ;
  vaem:description "An ordinal data type is a data type that specifies the properties of values that can easily be put in a one to one correspondence with a subset of the natural numbers. Examples include boolean, character, and integer data types."^^xsd:string ;
  rdfs:label "Ordinal Data Type"^^xsd:string ;
  rdfs:subClassOf qudt:ScalarDatatype ;
.
qudt:PaddingType
  rdf:type owl:Class ;
  dc:description "This describes how unused bits of a field are filled. Unused bits could be set to one or zero. A third option is \"don't care\"."^^xsd:string ;
  rdfs:label "Padding type"^^xsd:string ;
  rdfs:subClassOf qudt:EnumeratedValue ;
  owl:oneOf (
      <http://qudt.org/vocab/type/PadWithOnes>
      <http://qudt.org/vocab/type/PadWithZeros>
      <http://qudt.org/vocab/type/PadWithAny>
    ) ;
.
qudt:PartiallyOrdered
  rdf:type qudt:OrderedType ;
  qudt:description "Partial ordered structure."^^xsd:string ;
  qudt:literal "partial"^^xsd:string ;
  rdfs:label "Partially ordered"^^xsd:string ;
.
qudt:Percentage
  rdf:type owl:Class ;
  dc:description "A Scalar Datatype for expressing a dimensionless ratio."^^xsd:string ;
  vaem:description "A Scalar Datatype for expressing a dimensionless ratio."^^xsd:string ;
  rdfs:label "Percentage Type"^^xsd:string ;
  rdfs:subClassOf qudt:NumericType ;
.
qudt:PhysicalAddress
  rdf:type owl:Class ;
  dc:description "A \"Structured Datatype\"."^^xsd:string ;
  vaem:description "A \"Structured Datatype\"."^^xsd:string ;
  rdfs:label "Physical Address Type"^^xsd:string ;
  rdfs:subClassOf qudt:CompositeDatatype ;
.
qudt:PolarCoordinates
  rdf:type owl:Class ;
  dc:description "A set of  variables which fix a geometric object. If the coordinates of a point P are determined by the distance from P to the origin and the angle subtended by the radial vector at P and a fixed axis, they are known as polar coordinates. Typically, the angle is measured with respect to the x-axis."^^xsd:string ;
  vaem:description "A set of  variables which fix a geometric object. If the coordinates of a point P are determined by the distance from P to the origin and the angle subtended by the radial vector at P and a fixed axis, they are known as polar coordinates. Typically, the angle is measured with respect to the x-axis."^^xsd:string ;
  rdfs:label "Polar Coordinate System Type"^^xsd:string ;
  rdfs:subClassOf qudt:Coordinates ;
.
qudt:QuantityValueType
  rdf:type owl:Class ;
  rdfs:label "Quantity value type"^^xsd:string ;
  rdfs:subClassOf qudt:DimensionalDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:NumericType ;
      owl:onProperty qudt:elementType ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:QuantityType ;
      owl:onProperty qudt:basis ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:Unit ;
      owl:onProperty qudt:elementUnit ;
    ] ;
.
qudt:RawValueTupleMember
  rdf:type owl:Class ;
  rdfs:label "Raw value tuple member"^^xsd:string ;
  rdfs:subClassOf qudt:TupleMember ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:UnsignedIntegerType ;
      owl:onProperty qudt:elementType ;
    ] ;
  owl:equivalentClass [
      rdf:type owl:Class ;
      owl:intersectionOf (
          qudt:TupleMember
          [
            rdf:type owl:Restriction ;
            owl:allValuesFrom qudt:UnsignedIntegerType ;
            owl:onProperty qudt:elementType ;
          ]
        ) ;
    ] ;
.
qudt:RealDatatype
  rdf:type owl:Class ;
  dc:description "A real number is represented as a factor, called the mantissa, multiplied by a power (the exponent) of a base. Different bases yield different approximations to real numbers, and conversion between them is limited in accuracy.  Four floating-point types are defined in 'IEEE-754 Standard for Binary Floating-Point'. These types are 'single', 'extended single', 'double', and 'extended double'."^^xsd:string ;
  rdfs:label "Real Datatype"^^xsd:string ;
  rdfs:subClassOf qudt:NumericType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:base ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:maxExponent ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:precision ;
    ] ;
.
qudt:RealDoublePrecisionType
  rdf:type owl:Class ;
  dc:description """A real double precision data type specifies how a real number, or an approximation of a real number is stored in memory that occupies two words in computer memory, where the byte length of a word depends on machine address size of the computer processor. For example, on 32-bit machine architectures, a word is four bytes.

An example of a real double precision data type specification is the IEEE 754 standard for encoding binary or decimal floating point numbers in 8 bytes for storage on 32-bit machine architectures."""^^xsd:string ;
  vaem:description """A real double precision data type specifies how a real number, or an approximation of a real number is stored in memory that occupies two words in computer memory, where the byte length of a word depends on machine address size of the computer processor. For example, on 32-bit machine architectures, a word is four bytes.

An example of a real double precisoin data type specification is the IEEE 754 standard for encoding binary or decimal floating point numbers in 8 bytes for storage on 32-bit machine architectures."""^^xsd:string ;
  rdfs:label "Real Double Precision Type"^^xsd:string ;
  rdfs:subClassOf qudt:DoublePrecisionType ;
  rdfs:subClassOf qudt:RealDatatype ;
  owl:equivalentClass [
      rdf:type owl:Class ;
      owl:intersectionOf (
          qudt:RealDatatype
          qudt:DoublePrecisionType
        ) ;
    ] ;
.
qudt:RealSinglePrecisionType
  rdf:type owl:Class ;
  dc:description """A real single precision data type specifies how a real number, or an approximation of a real number is stored in memory that occupies one word in computer memory, where the byte length of a word depends on machine address size of the computer processor. For example, on 32-bit machine architectures, a word is four bytes.

An example of a real single precisoin data type specification is the IEEE 754 standard for encoding binary or decimal floating point numbers in 4 bytes for storage on 32-bit machine architectures."""^^xsd:string ;
  vaem:description """A real single precision data type specifies how a real number, or an approximation of a real number is stored in memory that occupies one word in computer memory, where the byte length of a word depends on machine address size of the computer processor. For example, on 32-bit machine architectures, a word is four bytes.

An example of a real single precisoin data type specification is the IEEE 754 standard for encoding binary or decimal floating point numbers in 4 bytes for storage on 32-bit machine architectures."""^^xsd:string ;
  rdfs:label "Real Single Precision Type"^^xsd:string ;
  rdfs:subClassOf qudt:RealDatatype ;
  rdfs:subClassOf qudt:SinglePrecisionType ;
  owl:equivalentClass [
      rdf:type owl:Class ;
      owl:intersectionOf (
          qudt:RealDatatype
          qudt:SinglePrecisionType
        ) ;
    ] ;
.
qudt:Record
  rdf:type owl:Class ;
  dc:description "A Record Type is a type whose values are records, i.e. aggregates of several items of possibly different types. The aggregated items are called fields or members and are usually identified or indexed by field labels."^^xsd:string ;
  vaem:description "A Record Type is a type whose values are records, i.e. aggregates of several items of possibly different types. The aggregated items are called fields or members and are usually identified or indexed by field labels."^^xsd:string ;
  rdfs:label "Record Type"^^xsd:string ;
  rdfs:subClassOf qudt:CompositeDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom <http://qudt.org/schema/type#FieldTypeList> ;
      owl:onProperty qudt:elementTypeList ;
    ] ;
.
qudt:ReferenceDatatype
  rdf:type owl:Class ;
  dc:description "A reference is an object containing information which refers to data stored elsewhere, as opposed to containing the data itself. A reference data type is a data type that specifies how a reference is represented and stored in memory, as well as the operations that can be performed on reference values. The most common example of a reference data type is a pointer."^^xsd:string ;
  vaem:description "A reference is an object containing information which refers to data stored elsewhere, as opposed to containing the data itself. A reference data type is a data type that specifies how a reference is represented and stored in memory, as well as the operations that can be performed on reference values. The most common example of a reference data type is a pointer. [Wikipedia]"^^xsd:string ;
  rdfs:label "Reference Data Type"^^xsd:string ;
  rdfs:subClassOf qudt:StructuredDatatype ;
.
qudt:ReferenceFrame
  rdf:type owl:Class ;
  dc:description """A reference frame (or frame of reference) in physics, may refer to a coordinate system or set of axes.
The frame serves as the datum to measure the position, orientation, and other properties of objects in it.
Reference frame may refer to an observational reference frame tied to the state of motion of an observer. 
Reference frame may also refer to both an observational reference frame and an attached coordinate system as a unit."""^^xsd:string ;
  rdfs:label "Reference Frame"^^xsd:string ;
  rdfs:subClassOf qudt:Concept ;
  rdfs:subClassOf skos:Concept ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:FrameType ;
      owl:onProperty qudt:frameType ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:realization ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:xAxisDefinition ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:xCoordinateDefinition ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:yAxisDefinition ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:yCoordinateDefinition ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:zAxisDefinition ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:zCoordinateDefinition ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty vaem:comment ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty vaem:description ;
    ] ;
.
qudt:RotatingReferenceFrame
  rdf:type owl:Class ;
  rdfs:label "Rotating reference frame"^^xsd:string ;
  rdfs:subClassOf qudt:ReferenceFrame ;
.
qudt:ScalarDatatype
  rdf:type owl:Class ;
  dc:description "Scalar data types are those that have a single value. The permissible values are defined over a domain that may be integers, float, character or boolean. Often a scalar data type is referred to as a primitive data type." ;
  rdfs:label "Scalar Data Type"^^xsd:string ;
  rdfs:subClassOf qudt:Datatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:Encoding ;
      owl:onProperty qudt:encoding ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom rdfs:Datatype ;
      owl:onProperty qudt:rdfsDatatype ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:bitOrder ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:bits ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:byteOrder ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:length ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:maxExclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:maxInclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:minExclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:minInclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:rdfsDatatype ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:bytes ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:encoding ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:minCardinality "0"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:ansiSQLName ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:minCardinality "0"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:microsoftSQLServerName ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:minCardinality "0"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:mySQLName ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:minCardinality "0"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:odbcName ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:minCardinality "0"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:oleDBName ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:minCardinality "0"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:oracleSQLName ;
    ] ;
.
qudt:Sequence
  rdf:type owl:Class ;
  dc:description "A \"Structured Datatype\"."^^xsd:string ;
  vaem:description "A \"Structured Datatype\"."^^xsd:string ;
  rdfs:label "Sequence"^^xsd:string ;
  rdfs:subClassOf qudt:Collection ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:Datatype ;
      owl:onProperty rdf:first ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:Sequence ;
      owl:onProperty rdf:rest ;
    ] ;
.
qudt:Set
  rdf:type owl:Class ;
  dc:description "A Set Type is an abstract data type that defines the properties of sets. A set is a collection (container) of certain values, without any particular order, and no repeated values. It corresponds with a finite set in mathematics."^^xsd:string ;
  vaem:description "A Set Type is an abstract data type that defines the properties of sets. A set is a collection (container) of certain values, without any particular order, and no repeated values. It corresponds with a finite set in mathematics."^^xsd:string ;
  rdfs:label "Set Type"^^xsd:string ;
  rdfs:subClassOf qudt:Collection ;
.
qudt:ShortIntegerType
  rdf:type owl:Class ;
  vaem:description "A Short Integer is an integer that can be represented in two octets (16 bits) of machine memory. Short integers may be signed or unsigned."^^xsd:string ;
  rdfs:label "Short Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:IntegerDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "16"^^xsd:int ;
      owl:onProperty qudt:bits ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "2"^^xsd:int ;
      owl:onProperty qudt:octets ;
    ] ;
.
qudt:SignedBigIntegerType
  rdf:type owl:Class ;
  dc:description "A Signed Big Integer is a signed integer that can be represented in eight octets (64 bits) of machine memory."^^xsd:string ;
  vaem:description "A Signed Big Integer is a signed integer that can be represented in eight octets (64 bits) of machine memory."^^xsd:string ;
  rdfs:label "Signed Big Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:BigIntegerType ;
  rdfs:subClassOf qudt:SignedIntegerType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "-2^{63}"^^xsd:string ;
      owl:onProperty qudt:minInclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "2^{63}-1"^^xsd:string ;
      owl:onProperty qudt:maxInclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "SI64"^^xsd:string ;
      owl:onProperty dtype:literal ;
    ] ;
.
qudt:SignedIntegerType
  rdf:type owl:Class ;
  dc:description "Signed Integers are integers can take on both positive and negative values."^^xsd:string ;
  vaem:description "Signed Integers are integers can take on both positive and negative values."^^xsd:string ;
  rdfs:label "Signed Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:IntegerDatatype ;
  rdfs:subClassOf qudt:SignedType ;
  owl:equivalentClass [
      rdf:type owl:Class ;
      owl:intersectionOf (
          qudt:IntegerDatatype
          qudt:SignedType
        ) ;
    ] ;
.
qudt:SignedLongIntegerType
  rdf:type owl:Class ;
  vaem:description "A Signed Long Integer is a signed integer that can be represented in four octets (32 bits) of machine memory."^^xsd:string ;
  rdfs:label "Signed Long Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:LongIntegerType ;
  rdfs:subClassOf qudt:SignedIntegerType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "-2^{31}"^^xsd:string ;
      owl:onProperty qudt:minInclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "2^{31}-1"^^xsd:string ;
      owl:onProperty qudt:maxInclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "UI32"^^xsd:string ;
      owl:onProperty dtype:literal ;
    ] ;
.
qudt:SignedMediumIntegerType
  rdf:type owl:Class ;
  dc:description "A \\textit{Signed Medium Integers} is an integer of 24 bits that can take on both positive and negative values."^^xsd:string ;
  rdfs:label "Signed Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:SignedIntegerType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue 3 ;
      owl:onProperty qudt:bytes ;
    ] ;
  owl:equivalentClass [
      rdf:type owl:Class ;
      owl:intersectionOf (
          qudt:IntegerDatatype
          qudt:SignedType
          [
            rdf:type owl:Restriction ;
            owl:hasValue 3 ;
            owl:onProperty qudt:bytes ;
          ]
        ) ;
    ] ;
.
qudt:SignedShortIntegerType
  rdf:type owl:Class ;
  vaem:description "A Signed Short Integer is a signed integer that can be represented in four octets (32 bits) of machine memory."^^xsd:string ;
  rdfs:label "Signed Short Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:ShortIntegerType ;
  rdfs:subClassOf qudt:SignedIntegerType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "-2^{15}"^^xsd:string ;
      owl:onProperty qudt:minInclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "2^{15}-1"^^xsd:string ;
      owl:onProperty qudt:maxInclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "SI16"^^xsd:string ;
      owl:onProperty dtype:literal ;
    ] ;
.
qudt:SignedType
  rdf:type owl:Class ;
  dc:description "A signed type is a numeric type that distinguishes between positive and negative numbers using an encoding scheme, such as sign and magnitude, one's compliment, and two's compliment to represent negative numbers."^^xsd:string ;
  vaem:description "A signed type is a numeric type that distinguishes between positive and negative numbers using an encoding scheme, such as sign and magnitude, one's compliment, and two's compliment to represent negative numbers."^^xsd:string ;
  rdfs:label "Signed Type"^^xsd:string ;
  rdfs:subClassOf qudt:NumericType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue <http://qudt.org/vocab/type/Signed> ;
      owl:onProperty qudt:signedness ;
    ] ;
  owl:disjointWith qudt:UnsignedType ;
  owl:equivalentClass [
      rdf:type owl:Class ;
      owl:intersectionOf (
          qudt:NumericType
          [
            rdf:type owl:Restriction ;
            owl:hasValue <http://qudt.org/vocab/type/Signed> ;
            owl:onProperty qudt:signedness ;
          ]
        ) ;
    ] ;
.
qudt:SignedVariableLengthIntegerType
  rdf:type owl:Class ;
  vaem:description "A Signed Variable Length Integer data type defines a data structure for representing signed integers that uses a variable number of bits depending on the magnitude of the integer. Typically, variable length integer data types are between one and 64 bits in length."^^xsd:string ;
  rdfs:label "Signed Variable Length Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:SignedIntegerType ;
  rdfs:subClassOf qudt:VariableLengthIntegerType ;
.
qudt:SignednessType
  rdf:type owl:Class ;
  dc:description "Specifics whether a value should be signed or unsigned."^^xsd:string ;
  rdfs:label "Signedness type"^^xsd:string ;
  rdfs:subClassOf qudt:EnumeratedValue ;
  owl:oneOf (
      <http://qudt.org/vocab/type/Unsigned>
      <http://qudt.org/vocab/type/Signed>
    ) ;
.
qudt:SinglePrecisionType
  rdf:type owl:Class ;
  dc:description "A single precision data type specifies how a numeric value, such as an integer or real number, is stored in memory that occupies one word in computer memory, where the byte length of a word depends on machine address size of the computer processor. For example, on 32-bit machine architectures, a word is four bytes, and so a single precision data value on a 32-bit machine architecture occupies four bytes of memory."^^xsd:string ;
  vaem:description "A single precision data type specifies how a numeric value, such as an integer or real number, is stored in memory that occupies one word in computer memory, where the byte length of a word depends on machine address size of the computer processor. For example, on 32-bit machine architectures, a word is four bytes, and so a single precision data value on a 32-bit machine architecture occupies four bytes of memory."^^xsd:string ;
  rdfs:label "Single Precision Type"^^xsd:string ;
  rdfs:subClassOf qudt:NumericType ;
.
qudt:SplineCalibrator
  rdf:type owl:Class ;
  rdfs:label "Spline calibrator"^^xsd:string ;
  rdfs:subClassOf qudt:Map ;
.
qudt:SplinePoint
  rdf:type owl:Class ;
  rdfs:label "Spline point"^^xsd:string ;
  rdfs:subClassOf qudt:Tuple ;
.
qudt:StateSpaceMatrix
  rdf:type owl:Class ;
  dc:description "In control engineering, a state space representation is a mathematical model of a physical system as a set of input, output and state variables related by first-order differential equations. To abstract from the number of inputs, outputs and states, the variables are expressed as vectors and the differential and algebraic equations are written in matrix form (the last one can be done when the dynamical system is linear and time invariant). "^^xsd:string ;
  vaem:description "In control engineering, a state space representation is a mathematical model of a physical system as a set of input, output and state variables related by first-order differential equations. To abstract from the number of inputs, outputs and states, the variables are expressed as vectors and the differential and algebraic equations are written in matrix form (the last one can be done when the dynamical system is linear and time invariant). "^^xsd:string ;
  rdfs:label "State Space Matrix Type"^^xsd:string ;
  rdfs:subClassOf qudt:Matrix ;
.
qudt:StateSpaceVector
  rdf:type owl:Class ;
  dc:description "A state vector in general control systems describes the observed states of an object in state space, e.g. in variables of the degrees of freedom for motion. As data types, state vector types are used to specify the structure of state vectors, such as how the observed state is encoded."^^xsd:string ;
  vaem:description "A state vector in general control systems describes the observed states of an object in state space, e.g. in variables of the degrees of freedom for motion. As data types, state vector types are used to specify the structure of state vectors, such as how the observed state is encoded."^^xsd:string ;
  rdfs:label "State Space Vector Type"^^xsd:string ;
  rdfs:subClassOf qudt:Vector ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:CoordinateSystem ;
      owl:onProperty qudt:coordinateSystem ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:coordinateSystem ;
    ] ;
.
qudt:StringEncodingType
  rdf:type owl:Class ;
  dc:description "A \"Encoding\" with the following instance(s): \"UTF-16 String\", \"UTF-8 Encoding\"."^^xsd:string ;
  rdfs:label "String Encoding Type"^^xsd:string ;
  rdfs:subClassOf qudt:Encoding ;
.
qudt:StringType
  rdf:type owl:Class ;
  dc:description "A String Type is a data type that specifies the properties of data structures that hold strings. "^^xsd:string ;
  vaem:description "A String Type is a data type that specifies the properties of data structures that hold strings. "^^xsd:string ;
  rdfs:label "String Type"^^xsd:string ;
  rdfs:subClassOf qudt:Array ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:CharacterType ;
      owl:onProperty qudt:elementType ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "0"^^xsd:int ;
      owl:onProperty qudt:typeMatrix ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "1"^^xsd:int ;
      owl:onProperty qudt:dimensionality ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:maxLength ;
    ] ;
.
qudt:StringUTF16
  rdf:type owl:Class ;
  dc:description "String UTF-16 Type is a string data type that specifies the properties of string data structures which encode strings using the UTF-16 encoding. UTF-16 is the native internal representation of text in the Microsoft Windows NT/Windows 2000/Windows XP/Windows CE, Qualcomm BREW, and Symbian operating systems; the Java and .NET byte code environments; Mac OS X's Cocoa and Core Foundation frameworks; and the Qt cross-platform graphical widget toolkit."^^xsd:string ;
  vaem:description "String UTF-16 Type is a string data type that specifies the properties of string data structures which encode strings using the UTF-16 encoding. UTF-16 is the native internal representation of text in the Microsoft Windows NT/Windows 2000/Windows XP/Windows CE, Qualcomm BREW, and Symbian operating systems; the Java and .NET byte code environments; Mac OS X's Cocoa and Core Foundation frameworks; and the Qt cross-platform graphical widget toolkit."^^xsd:string ;
  rdfs:label "String UTF16 Type"^^xsd:string ;
  rdfs:subClassOf qudt:StringType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue <http://qudt.org/vocab/type/UTF16-CHAR> ;
      owl:onProperty qudt:elementType ;
    ] ;
.
qudt:StringUTF8
  rdf:type owl:Class ;
  dc:description "String UTF-8 Type is a string data type that specifies the properties of string data structures which encode strings using the UTF-8 encoding. UTF-8 includes ASCII, otherwise referred to as IA-5 (International Alphabet 5, as standardized by International Organization for Standardization [ISO]) as the first 128 values. The Internet Engineering Task Force (IETF) requires all Internet protocols to identify the encoding used for character data with UTF-8 as at least one supported encoding. The Internet Mail Consortium (IMC) recommends that all e-mail programs must be able to display and create mail using UTF-8."^^xsd:string ;
  vaem:description "String UTF-8 Type is a string data type that specifies the properties of string data structures which encode strings using the UTF-8 encoding. UTF-8 includes ASCII, otherwise referred to as IA-5 (International Alphabet 5, as standardized by International Organization for Standardization [ISO]) as the first 128 values. The Internet Engineering Task Force (IETF) requires all Internet protocols to identify the encoding used for character data with UTF-8 as at least one supported encoding. The Internet Mail Consortium (IMC) recommends that all e-mail programs must be able to display and create mail using UTF-8."^^xsd:string ;
  rdfs:label "String UTF8 Type"^^xsd:string ;
  rdfs:subClassOf qudt:StringType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue <http://qudt.org/vocab/type/UTF8-CHAR> ;
      owl:onProperty qudt:elementType ;
    ] ;
.
qudt:StructuredDatatype
  rdf:type owl:Class ;
  dc:description "A \\textit{Structured Datatype}, in contrast to scalar data types, is used to characterize classes of more complex data structures, such as linked or indexed lists, trees, ordered trees, and multi-dimensional file formats."^^xsd:string ;
  rdfs:label "Structured Data Type"^^xsd:string ;
  rdfs:subClassOf qudt:Datatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:Datatype ;
      owl:onProperty qudt:elementType ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:elementType ;
    ] ;
.
qudt:Table
  rdf:type owl:Class ;
  dc:description "A Table Type is a data type that specifies the properties of table data structures. A table is both a mode of visual communication and a means of arranging data. The use of tables is pervasive throughout NASA The precise conventions and terminology for describing tables varies depending on the context. Moreover, tables differ significantly in variety, structure, flexibility, notation, representation and use."^^xsd:string ;
  vaem:description "A Table Type is a data type that specifies the properties of table data structures. A table is both a mode of visual communication and a means of arranging data. The use of tables is pervasive throughout NASA The precise conventions and terminology for describing tables varies depending on the context. Moreover, tables differ significantly in variety, structure, flexibility, notation, representation and use."^^xsd:string ;
  rdfs:label "Table Type"^^xsd:string ;
  rdfs:subClassOf qudt:Array ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:columns ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:rows ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "2"^^xsd:int ;
      owl:onProperty qudt:dimensionality ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty qudt:byRow ;
    ] ;
.
qudt:TaggedEnumeration
  rdf:type owl:Class ;
  dc:description "An enumeration where each literal  has a tag that is a non-negative integer. These enumerations are likely to have their literals encoded - hence the need for the tag."^^xsd:string ;
  vaem:description "An enumeration where each literal  has a tag that is a non-negative integer. These enumerations are likely to have their literals encoded - hence the need for the tag."^^xsd:string ;
  rdfs:label "Tagged Enumeration"^^xsd:string ;
  rdfs:subClassOf qudt:Enumeration ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty dtype:code ;
    ] ;
  owl:equivalentClass [
      rdf:type owl:Class ;
      owl:intersectionOf (
          qudt:Enumeration
          [
            rdf:type owl:Restriction ;
            owl:cardinality "1"^^xsd:int ;
            owl:onProperty dtype:code ;
          ]
        ) ;
    ] ;
.
qudt:TextStringType
  rdf:type owl:Class ;
  dc:description "A text string. Encodings can be specified as subclass or in connection to character arrays in Structured Datatypes."^^xsd:string ;
  vaem:description "A text string. Encodings can be specified as subclass or in connection to character arrays in Structured Datatypes."^^xsd:string ;
  rdfs:label "Text String Type"^^xsd:string ;
  rdfs:subClassOf qudt:StringType ;
.
qudt:Three-Tuple
  rdf:type owl:Class ;
  dc:description "A three-tuple is a tuple with exactly three members. A Three-Tuple Type is a data type that defines the type properties of a class of three-tuples and their members."^^xsd:string ;
  vaem:description "A three-tuple is a tuple with exactly three members. A Three-Tuple Type is a data type that defines the type properties of a class of three-tuples and their members."^^xsd:string ;
  rdfs:label "Three-Tuple Type"^^xsd:string ;
  rdfs:subClassOf qudt:N-Tuple ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "3"^^xsd:int ;
      owl:onProperty qudt:elementType ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "3"^^xsd:int ;
      owl:onProperty qudt:elementTypeCount ;
    ] ;
.
qudt:ThreeBodyRotatingCoordinateSystem
  rdf:type owl:Class ;
  dc:description "The lunar coordinate systems are primarily used when operating in close proximity to the Moon. There are, however, a few additional coordinate systems that are also useful when analyzing (and depicting) trajectories in the vicinity of the Earth-Moon system. They are rotating coordinate systems associated with two different three-body systems: the Sun-Earth-spacecraft system and the Earth-Moon-spacecraft system. The Sun-Earth and Earth-Moon rotating coordinate frames are defined as follows. The pole vector or Z-axis of the coordinate frame is set equal to the instantaneous orbit normal of the secondary (smaller) body about the primary (larger) body and the X-axis is set equal to the vector from the primary body center of mass (CM) to the secondary body CM. The X-axis rotates at a rate equal to the instantaneous rotation rate of the secondary body about the primary body."^^xsd:string ;
  rdfs:label "Three Body Rotating Coordinate System Type"^^xsd:string ;
  rdfs:subClassOf qudt:AerospaceCoordinateSystem ;
.
qudt:TimeDataType
  rdf:type owl:Class ;
  dtype:value <http://qudt.org/vocab/type/TIME> ;
  rdfs:label "Time data type"^^xsd:string ;
  rdfs:subClassOf qudt:Enumeration ;
.
qudt:TimeSeriesArray
  rdf:type owl:Class ;
  dc:description "A Time Series Array Type is a data type that specifies the properties of arrays that hold time series data. A time series is a sequence of data points, measured at successive time intervals. The time intervals may be uniformly or non-uniformly spaced."^^xsd:string ;
  vaem:description "A Time Series Array Type is a data type that specifies the properties of arrays that hold time series data. A time series is a sequence of data points, measured typically at successive times, spaced at uniform or non-uniform time intervals."^^xsd:string ;
  rdfs:label "Time Series Array Type"^^xsd:string ;
  rdfs:subClassOf qudt:Array ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:StateSpaceVector ;
      owl:onProperty <http://qudt.org/schema/type#vector> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:TimeStringType ;
      owl:onProperty <http://qudt.org/schema/type#incrementDatatype> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:hasDimensionVector ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#incrementDatatype> ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#vector> ;
    ] ;
.
qudt:TimeStringType
  rdf:type owl:Class ;
  dc:description "Time takes a number of forms, depending on the units used (e.g., year, day, minute, millisecond, or combinations thereof) and the origin (i.e., time zero) to which the time value is related."^^xsd:string ;
  vaem:description "Time takes a number of forms, depending on the units used (e.g., year, day, minute, millisecond, or combinations thereof) and the origin (i.e., time zero) to which the time value is related."^^xsd:string ;
  rdfs:label "Time Type"^^xsd:string ;
  rdfs:subClassOf qudt:DateTimeStringType ;
.
qudt:TotallyOrdered
  rdf:type qudt:OrderedType ;
  qudt:description "Totally ordered structure."^^xsd:string ;
  qudt:literal "total"^^xsd:string ;
  rdfs:label "Totally ordered"^^xsd:string ;
.
qudt:TrajectoryCoordinateSystem
  rdf:type owl:Class ;
  dc:description "A \"Coordinate System\"."^^xsd:string ;
  rdfs:label "Trajectory Coordinate System"^^xsd:string ;
  rdfs:subClassOf qudt:AerospaceCoordinateSystem ;
.
qudt:Tree
  rdf:type owl:Class ;
  dc:description "A \\textit{Tree} is a data type that defines the properties of data structures that represent trees. A tree is a graph data structure accessed beginning at the root node. Each node is either a leaf or an internal node. An internal node has one or more child nodes and is called the parent of its child nodes. Leaf nodes have no chidren. Nodes that share the same parent are siblings. In graph theoretic terminology, a tree is a connected, undirected, acyclic graph."^^xsd:string ;
  rdfs:label "Tree Type"^^xsd:string ;
  rdfs:subClassOf qudt:Graph ;
.
qudt:Triplet
  rdf:type owl:Class ;
  dc:description "A \"Tuple\"."^^xsd:string ;
  vaem:description "A \"Tuple\"."^^xsd:string ;
  rdfs:label "Triplet"^^xsd:string ;
  rdfs:subClassOf qudt:Three-Tuple ;
  owl:equivalentClass qudt:Three-Tuple ;
.
qudt:Tuple
  rdf:type owl:Class ;
  dc:description "The term \\textit{Tuple} originated as an abstraction of the sequence: single, double, triple, quadruple, quintuple, n-tuple.  In mathematics, a tuple is a finite sequence (also known as an \\textit{Ordered List}) of objects, each of a specified type. The n can be any non-negative integer."^^xsd:string ;
  vaem:description "The term Tuple originated as an abstraction of the sequence: single, double, triple, quadruple, quintuple, n-tuple.  In mathematics, a tuple is a finite sequence (also known as an \"ordered list\") of objects, each of a specified type. The n can be any nonnegative integer." ;
  rdfs:label "Tuple Type"^^xsd:string ;
  rdfs:subClassOf qudt:CompositeDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:TupleMember ;
      owl:onProperty qudt:elementType ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:elementTypeCount ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:length ;
    ] ;
.
qudt:TupleMember
  rdf:type owl:Class ;
  vaem:description "A Tuple Member Type is a data type that defines the properties of a member of a tuple. It is used to provide fine grained type specification to the elements of tuples."^^xsd:string ;
  rdfs:label "Tuple Member Type"^^xsd:string ;
  rdfs:subClassOf qudt:CompositeDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:ScalarDatatype ;
      owl:onProperty qudt:elementType ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty <http://qudt.org/schema/type#orderInStructure> ;
    ] ;
.
qudt:Two-Tuple
  rdf:type owl:Class ;
  dc:description "A 2-tuple is called a pair. For example, a complex number can be represented as a 2-tuple, and 2D coordinates are sometimes represented as 2-tuples." ;
  vaem:description "A 2-tuple is called a pair. For example, a complex number can be represented as a 2-tuple, and 2D coordinates are sometimes represented as 2-tuples." ;
  rdfs:label "Two-Tuple Type"^^xsd:string ;
  rdfs:subClassOf qudt:N-Tuple ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "2"^^xsd:int ;
      owl:onProperty qudt:elementType ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "2"^^xsd:int ;
      owl:onProperty qudt:elementTypeCount ;
    ] ;
.
qudt:TypeList
  rdf:type owl:Class ;
  rdfs:label "Type list"^^xsd:string ;
  rdfs:subClassOf qudt:Datatype ;
.
qudt:TypeVector
  rdf:type owl:Class ;
  dc:description "A Type Vector is a vector whose elements are data types. They are used, for instance, to specify the type of each component of a vector or class of vectors. A Type Vector Type is a further abstraction that specifies the structure of Type Vectors."^^xsd:string ;
  vaem:description "A Type Vector is a vector whose elements are data types. They are used, for instance, to specify the type of each component of a vector or class of vectors. A Type Vector Type is a further abstraction that specifies the structure of Type Vectors."^^xsd:string ;
  rdfs:label "Type Vector Type"^^xsd:string ;
  rdfs:subClassOf qudt:Vector ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onClass qudt:TypeVector ;
      owl:onProperty qudt:typeVector ;
    ] ;
.
qudt:UTC-DayTime
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  dc:description "YYYY-DDDThh:mm:ss.ddZ, where each character is an ASCII character using one octet with the following meanings: YYYY = Year in four-character subfield with values 0001-9999, DDD = Day of year in three-character subfield with values 001-365 or -366, T =  Calendar-Time separator, hh = Hour in two-character subfield with values 00-23,  mm = Minute in two-character subfield with values 00-59, ss = Second in two-character subfield with values 00-59 (-58 or -60 during leap seconds), dd = Decimal fraction of second in one- to n-character subfield, each d has values 0-9, and Z = time code terminator (optional)"^^xsd:string ;
  rdfs:label "UTC Day time"^^xsd:string ;
  rdfs:subClassOf xsd:string ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:length "22"^^xsd:nonNegativeInteger ;
          ]
          [
            xsd:pattern "[0-9]{4}\\\\-[0-9]{3}T[0-9]{2}:[0-9]{2}:[0-9]{2}\\\\.[0-9]{2}Z?"^^xsd:string ;
          ]
        ) ;
    ] ;
.
qudt:Unordered
  rdf:type qudt:OrderedType ;
  qudt:description "Unordered structure."^^xsd:string ;
  qudt:literal "unordered" ;
  rdfs:label "Unordered"^^xsd:string ;
.
qudt:UnsignedBigIntegerType
  rdf:type owl:Class ;
  vaem:description "An Unsgned Big Integer is an unsigned integer that can be represented in eight octets (64 bits) of machine memory."^^xsd:string ;
  rdfs:label "Unsigned Big Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:BigIntegerType ;
  rdfs:subClassOf qudt:UnsignedIntegerType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "0"^^xsd:string ;
      owl:onProperty qudt:minInclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "2^{64}-1"^^xsd:string ;
      owl:onProperty qudt:maxInclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "UI64"^^xsd:string ;
      owl:onProperty dtype:literal ;
    ] ;
.
qudt:UnsignedIntegerType
  rdf:type owl:Class ;
  dc:description "Unsgned Integers are integers that are either strictly non-negative or non-positive."^^xsd:string ;
  vaem:description "Unsgned Integers are integers that are either strictly non-negative or non-positive."^^xsd:string ;
  rdfs:label "Unsigned Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:IntegerDatatype ;
  rdfs:subClassOf qudt:UnsignedType ;
  owl:disjointWith qudt:SignedIntegerType ;
  owl:equivalentClass [
      rdf:type owl:Class ;
      owl:intersectionOf (
          qudt:IntegerDatatype
          qudt:UnsignedType
        ) ;
    ] ;
.
qudt:UnsignedLongIntegerType
  rdf:type owl:Class ;
  vaem:description "An Unsigned Long Integer is an unsigned integer that can be represented in four octets (32 bits) of machine memory."^^xsd:string ;
  rdfs:label "Unsigned Long Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:LongIntegerType ;
  rdfs:subClassOf qudt:UnsignedIntegerType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "0"^^xsd:string ;
      owl:onProperty qudt:minInclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "2^{32}-1"^^xsd:string ;
      owl:onProperty qudt:maxInclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "UI32"^^xsd:string ;
      owl:onProperty dtype:literal ;
    ] ;
.
qudt:UnsignedMediumIntegerType
  rdf:type owl:Class ;
  dc:description "An \\textit{Unsigned Medium Integers} is an integer of 24 bits that only takes on both positive values."^^xsd:string ;
  rdfs:label "Signed Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:UnsignedIntegerType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue 3 ;
      owl:onProperty qudt:bytes ;
    ] ;
  owl:equivalentClass [
      rdf:type owl:Class ;
      owl:intersectionOf (
          qudt:IntegerDatatype
          qudt:SignedType
        ) ;
    ] ;
.
qudt:UnsignedShortIntegerType
  rdf:type owl:Class ;
  vaem:description "An Unsigned Short Integer is an unsigned integer that can be represented in four octets (32 bits) of machine memory."^^xsd:string ;
  rdfs:label "Unsigned Short Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:ShortIntegerType ;
  rdfs:subClassOf qudt:UnsignedIntegerType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "0"^^xsd:string ;
      owl:onProperty qudt:minInclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "2^{16}-1"^^xsd:string ;
      owl:onProperty qudt:maxInclusive ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "UI16"^^xsd:string ;
      owl:onProperty dtype:literal ;
    ] ;
.
qudt:UnsignedType
  rdf:type owl:Class ;
  dc:description "An unsigned data type is a numeric type that does not distinguish between positive and negative values."^^xsd:string ;
  vaem:description "An unsigned data type is a numeric type that does not distinguish between positive and negative values."^^xsd:string ;
  rdfs:label "Unsigned Type"^^xsd:string ;
  rdfs:subClassOf qudt:NumericType ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue <http://qudt.org/vocab/type/Unsigned> ;
      owl:onProperty qudt:signedness ;
    ] ;
  owl:disjointWith qudt:SignedType ;
  owl:equivalentClass [
      rdf:type owl:Class ;
      owl:intersectionOf (
          qudt:NumericType
          [
            rdf:type owl:Restriction ;
            owl:hasValue <http://qudt.org/vocab/type/Unsigned> ;
            owl:onProperty qudt:signedness ;
          ]
        ) ;
    ] ;
.
qudt:UnsignedVariableLengthIntegerType
  rdf:type owl:Class ;
  vaem:description "An Unsigned Variable Length Integer data type defines a data structure for representing unsigned integers that uses a variable number of bits depending on the magnitude of the integer. Typically, variable length integer data types are between one and 64 bits in length."^^xsd:string ;
  rdfs:label "Unsigned Variable Length Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:UnsignedIntegerType ;
  rdfs:subClassOf qudt:VariableLengthIntegerType ;
.
qudt:VariableIntervalTimeSeriesArray
  rdf:type owl:Class ;
  dc:description "A Variable Interval Time Series Array Type is a data type that specifies the properties of arrays that hold time series data that has been sampled over non-uniformly spaced time intervals. A time series is a sequence of data points, measured typically at successive times, spaced at uniform or non-uniform time intervals. For variable interval time series, the successive time intervals may follow a repeating pattern, or may be completely random."^^xsd:string ;
  vaem:description "A Variable Interval Time Series Array Type is a data type that specifies the properties of arrays that hold time series data that has been sampled over non-uniformly spaced time intervals. A time series is a sequence of data points, measured typically at successive times, spaced at uniform or non-uniform time intervals. For variable interval time series, the successive time intervals may follow a repeating pattern, or may be completely random."^^xsd:string ;
  rdfs:label "Variable Interval Time Series Array Type"^^xsd:string ;
  rdfs:subClassOf qudt:TimeSeriesArray ;
.
qudt:VariableLengthIntegerType
  rdf:type owl:Class ;
  vaem:description "A Variable Length Integer data type defines a data structure for representing integers that uses a variable number of bits depending on the magnitude of the integer. Typically, variable length integer data types are between one and 64 bits in length."^^xsd:string ;
  rdfs:label "Variable Length Integer Type"^^xsd:string ;
  rdfs:subClassOf qudt:IntegerDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "1"^^xsd:int ;
      owl:onProperty qudt:minBits ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "64"^^xsd:int ;
      owl:onProperty qudt:maxBits ;
    ] ;
.
qudt:Vector
  rdf:type owl:Class ;
  dc:description "A Vector Type is a data type that specifies the properties of data structures that hold vectors."^^xsd:string ;
  vaem:description "A Vector Type is a data type that specifies the properties of data structures that hold vectors."^^xsd:string ;
  rdfs:label "Vector Type"^^xsd:string ;
  rdfs:subClassOf qudt:CompositeDatatype ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:ReferenceFrame ;
      owl:onProperty qudt:referenceFrame ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:dimension ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:dimensionality ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:hasValue "1"^^xsd:int ;
      owl:onProperty qudt:dimensionality ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty qudt:referenceFrame ;
    ] ;
.
qudt:VectorArray
  rdf:type owl:Class ;
  dc:description "A vector array is an array whose elements are all state vectors. As a data type, a vector array type is used to describe the structure of vector array valued quantities by specifying the types of the array's elements."^^xsd:string ;
  vaem:description "A vector array is an array whose elements are all state vectors. As a data type, a vector array type is used to describe the structure of vector array valued quantities by specifying the types of the array's elements."^^xsd:string ;
  rdfs:label "Vector Array Type"^^xsd:string ;
  rdfs:subClassOf qudt:Array ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:StateSpaceVector ;
      owl:onProperty <http://qudt.org/schema/type#vector> ;
    ] ;
.
qudt:VehicleCoordinateSystem
  rdf:type owl:Class ;
  rdfs:label "Vehicle coordinate system"^^xsd:string ;
  rdfs:subClassOf qudt:AerospaceCoordinateSystem ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:AxialOrientationType ;
      owl:onProperty qudt:pitchRotationDefinition ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:AxialOrientationType ;
      owl:onProperty qudt:rollRotationDefinition ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom qudt:AxialOrientationType ;
      owl:onProperty qudt:yawRotationDefinition ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:pitchRotationDefinition ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:rollRotationDefinition ;
    ] ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty qudt:yawRotationDefinition ;
    ] ;
.
qudt:VisualCueEnumeration
  rdf:type owl:Class ;
  rdfs:label "Visual Type"^^xsd:string ;
  rdfs:subClassOf qudt:ModalEnumeration ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:allValuesFrom <http://qudt.org/schema/type#VisualCue> ;
      owl:onProperty qudt:defaultValue ;
    ] ;
  owl:disjointWith qudt:AuralCueEnumeration ;
  owl:disjointWith qudt:IconicCueEnumeration ;
  owl:disjointWith qudt:KinestheticCueEnumeration ;
.
qudt:accuracy
  rdf:type owl:DatatypeProperty ;
  rdf:type owl:FunctionalProperty ;
  vaem:description """Accuracy is the degree to which a given quantity is correct and free from error. For example, a quantity specified as 100+/-1 has an (absolute) accuracy of +/-1 (meaning its true value can fall in the range 99-101), while a quantity specified as 100+/-2% has a (relative) accuracy of +/-2% (meaning its true value can fall in the range 98-102).

The concepts of accuracy and precision are both closely related and often confused. While the accuracy of a number x is given by the number of significant decimal (or other) digits to the right of the decimal point in x, the precision of x is the total number of significant decimal (or other) digits. """^^xsd:string ;
  rdfs:label "accuracy"^^xsd:string ;
  rdfs:range xsd:nonNegativeInteger ;
.
qudt:alignment
  rdf:type owl:ObjectProperty ;
  rdfs:label "alignment"^^xsd:string ;
.
qudt:allowedPattern
  rdf:type owl:DatatypeProperty ;
  vaem:description "This property relates a date string encoding (c.f. type:DateStringEncodingType) to one or more XML Schema compliant regular expressions that together determine the allowed lexical expressions that can be unambiguously parsed to determine a temporal quantity."^^xsd:string ;
  rdfs:label "allowed pattern"^^xsd:string ;
  rdfs:range xsd:string ;
.
qudt:ansiSQLName
  rdf:type owl:DatatypeProperty ;
  rdfs:label "ANSI SQL name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf qudt:designator ;
.
qudt:arg1Type
  rdf:type owl:ObjectProperty ;
  vaem:description "This property relates a funciton data type with the type of its arg1."^^xsd:string ;
  rdfs:label "arg1Type"^^xsd:string ;
  rdfs:subPropertyOf qudt:argType ;
.
qudt:arg2Type
  rdf:type owl:ObjectProperty ;
  vaem:description "This property relates a funciton data type with the type of its arg2."^^xsd:string ;
  rdfs:label "arg2Type"^^xsd:string ;
  rdfs:subPropertyOf qudt:argType ;
.
qudt:arg3Type
  rdf:type owl:ObjectProperty ;
  vaem:description "This property relates a funciton data type with the type of its arg3."^^xsd:string ;
  rdfs:label "arg3Type"^^xsd:string ;
  rdfs:subPropertyOf qudt:argType ;
.
qudt:argType
  rdf:type owl:ObjectProperty ;
  vaem:description "This property relates a function data type with the type of one of its arguments."^^xsd:string ;
  rdfs:label "argType"^^xsd:string ;
  rdfs:subPropertyOf qudt:elementType ;
.
qudt:base
  rdf:type owl:DatatypeProperty ;
  rdfs:label "base"^^xsd:string ;
  rdfs:range xsd:nonNegativeInteger ;
.
qudt:basis
  rdf:type owl:ObjectProperty ;
  rdfs:label "basis"^^xsd:string ;
.
qudt:bitOrder
  rdf:type owl:ObjectProperty ;
  rdfs:label "bit order"^^xsd:string ;
  rdfs:range qudt:EndianType ;
.
qudt:bits
  rdf:type owl:DatatypeProperty ;
  rdfs:label "bits"^^xsd:string ;
  rdfs:range xsd:positiveInteger ;
  rdfs:subPropertyOf qudt:maxBits ;
  rdfs:subPropertyOf qudt:minBits ;
.
qudt:bounded
  rdf:type owl:DatatypeProperty ;
  vaem:description "A datatype is bounded if its value space has either a finite upper and lower bound. Either bound may be inclusive or exclusive. "^^xsd:string ;
  rdfs:label "bounded"^^xsd:string ;
  rdfs:range xsd:boolean ;
.
qudt:byRow
  rdf:type owl:DatatypeProperty ;
  rdf:type owl:DeprecatedProperty ;
  dc:description "A boolean to specify whether an array is presented row by row or column by column."^^xsd:string ;
  vaem:rationale "Replaced with an enumeration. See type:ArrayDataOrderType"^^xsd:string ;
  rdfs:label "by row"^^xsd:string ;
  rdfs:range xsd:boolean ;
.
qudt:byteOrder
  rdf:type owl:ObjectProperty ;
  dc:description "Byte order is an enumeration of two values: 'Big Endian' and 'Little Endian' and is used to denote whether the most signiticant byte is either first or last, respectively." ;
  rdfs:label "byte order"^^xsd:string ;
  rdfs:range qudt:EndianType ;
.
qudt:bytes
  rdf:type owl:DatatypeProperty ;
  rdfs:label "bytes"^^xsd:string ;
  rdfs:range xsd:nonNegativeInteger ;
.
qudt:cName
  rdf:type owl:DatatypeProperty ;
  rdfs:label "C name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf qudt:designator ;
.
qudt:cardinality
  rdf:type owl:ObjectProperty ;
  rdfs:label "cardinality"^^xsd:string ;
.
qudt:columns
  rdf:type owl:DatatypeProperty ;
  rdfs:label "columns"^^xsd:string ;
  rdfs:range xsd:positiveInteger ;
.
qudt:coordinateCenter
  rdf:type owl:ObjectProperty ;
  rdfs:domain qudt:CoordinateSystem ;
  rdfs:label "coordinate center"^^xsd:string ;
  rdfs:range qudt:CoordinateCenterType ;
  skos:prefLabel "coordinate center"^^xsd:string ;
.
qudt:coordinateSystem
  rdf:type owl:ObjectProperty ;
  rdfs:label "coordinate system"^^xsd:string ;
.
qudt:coordinateSystemFrame
  rdf:type owl:ObjectProperty ;
  rdfs:label "coordinate system frame"^^xsd:string ;
.
qudt:dataOrder
  rdf:type owl:ObjectProperty ;
  rdfs:label "data order"^^xsd:string ;
.
qudt:defaultValue
  rdf:type owl:AnnotationProperty ;
  rdfs:label "Default Value"^^xsd:string ;
.
qudt:dimension
  rdf:type owl:DatatypeProperty ;
  dc:description "The number of elements in a vector."^^xsd:string ;
  rdfs:label "dimension"^^xsd:string ;
  rdfs:range xsd:positiveInteger ;
.
qudt:dimensionality
  rdf:type owl:DatatypeProperty ;
  dc:description "The number of dimensions making up an array. For example a 4 by 4 array has a dimensionality of 2. Whereas a vector or a string has a dimensionality of 1."^^xsd:string ;
  rdfs:label "dimensionality"^^xsd:string ;
  rdfs:range xsd:positiveInteger ;
.
qudt:elementKind
  rdf:type owl:ObjectProperty ;
  vaem:description "This property is used to describe the quantity kind for a dimensional data type."^^xsd:string ;
  rdfs:label "element kind"^^xsd:string ;
  rdfs:subPropertyOf qudt:elementKind ;
.
qudt:elementType
  rdf:type owl:ObjectProperty ;
  vaem:description "This property is used to relate a structured data type with the data type the structured type's elements. It is used for structured data types with elements that are all of the same type."^^xsd:string ;
  vaem:todo "Change name to type:elementDataType"^^xsd:string ;
  rdfs:label "element type"^^xsd:string ;
.
qudt:elementTypeCount
  rdf:type owl:DatatypeProperty ;
  vaem:description "This property determines the allowed number of element types that a structured data type may have."^^xsd:string ;
  rdfs:label "element type count"^^xsd:string ;
  rdfs:range xsd:nonNegativeInteger ;
.
qudt:elementTypeList
  rdf:type owl:ObjectProperty ;
  vaem:description "This property is used to relate a structured data type with a list of data types. The list members determine the types of structured type's elements. It is used for structured data types with elements that are of different types."^^xsd:string ;
  rdfs:label "element type list"^^xsd:string ;
.
qudt:elementUnit
  rdf:type owl:FunctionalProperty ;
  rdf:type owl:ObjectProperty ;
  rdfs:label "element unit"^^xsd:string ;
.
qudt:encodedValue
  rdf:type owl:DatatypeProperty ;
  rdfs:label "encoded value"^^xsd:string ;
.
qudt:encoding
  rdf:type owl:ObjectProperty ;
  rdfs:label "encoding"^^xsd:string ;
.
qudt:encodingDescription
  rdf:type owl:DatatypeProperty ;
  rdfs:label "encoding description"^^xsd:string ;
  rdfs:range xsd:string ;
.
qudt:fieldLabels
  rdf:type owl:ObjectProperty ;
  vaem:description "This property is used to list the field labels for a record type."^^xsd:string ;
  rdfs:label "field labels"^^xsd:string ;
.
qudt:fieldName
  rdf:type owl:DatatypeProperty ;
  rdfs:label "field name"^^xsd:string ;
  rdfs:range xsd:string ;
.
qudt:float_X
  rdf:type owl:DatatypeProperty ;
  rdfs:label "float X"^^xsd:string ;
  rdfs:range xsd:anySimpleType ;
.
qudt:float_Y
  rdf:type owl:DatatypeProperty ;
  rdfs:label "float Y"^^xsd:string ;
  rdfs:range xsd:anySimpleType ;
.
qudt:float_Z
  rdf:type owl:DatatypeProperty ;
  rdfs:label "float Z"^^xsd:string ;
  rdfs:range xsd:anySimpleType ;
.
qudt:frameType
  rdf:type owl:ObjectProperty ;
  rdfs:label "frame type"^^xsd:string ;
.
qudt:functionArity
  rdf:type owl:DatatypeProperty ;
  vaem:description "This property is used to state the number of arguments for a function type."^^xsd:string ;
  rdfs:label "function arity"^^xsd:string ;
  rdfs:range xsd:nonNegativeInteger ;
.
qudt:hasDimension
  rdf:type owl:ObjectProperty ;
  rdfs:label "has dimension"^^xsd:string ;
.
qudt:hasDimensionVector
  rdf:type owl:ObjectProperty ;
  rdfs:label "has dimension vector"^^xsd:string ;
  rdfs:range qudt:DimensionVector ;
.
qudt:hexbinary
  rdf:type rdfs:Datatype ;
  rdfs:label "hexbinary"^^xsd:string ;
  rdfs:subClassOf xsd:string ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:pattern "[0-9A-F]*"^^xsd:string ;
          ]
        ) ;
    ] ;
.
qudt:integer1to12
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "integer 1..12"^^xsd:string ;
  rdfs:subClassOf xsd:integer ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:integer ;
      owl:withRestrictions (
          [
            xsd:minInclusive 1 ;
          ]
          [
            xsd:maxInclusive 12 ;
          ]
        ) ;
    ] ;
.
qudt:integer1to31
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "integer 1..31"^^xsd:string ;
  rdfs:subClassOf xsd:integer ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:integer ;
      owl:withRestrictions (
          [
            xsd:minInclusive 1 ;
          ]
          [
            xsd:maxInclusive 31 ;
          ]
        ) ;
    ] ;
.
qudt:inverted
  rdf:type owl:DatatypeProperty ;
  rdfs:label "inverted"^^xsd:string ;
  rdfs:range xsd:boolean ;
.
qudt:javaName
  rdf:type owl:DatatypeProperty ;
  rdfs:label "java name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf qudt:designator ;
.
qudt:jsName
  rdf:type owl:DatatypeProperty ;
  rdfs:label "Javascript name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf qudt:designator ;
.
qudt:length
  rdf:type owl:DatatypeProperty ;
  dc:description "The length of a structure, for example the size of a vector" ;
  rdfs:label "length"^^xsd:string ;
  rdfs:range xsd:nonNegativeInteger ;
  rdfs:subPropertyOf qudt:maxLength ;
  rdfs:subPropertyOf qudt:minLength ;
.
qudt:lowerBound
  rdf:type owl:DatatypeProperty ;
  rdfs:label "lower bound"^^xsd:string ;
  rdfs:range xsd:anySimpleType ;
.
qudt:matlabName
  rdf:type owl:DatatypeProperty ;
  rdfs:label "matlab name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf qudt:designator ;
.
qudt:maxBits
  rdf:type owl:DatatypeProperty ;
  rdfs:label "maximum bits"^^xsd:string ;
  rdfs:range xsd:positiveInteger ;
.
qudt:maxDepth
  rdf:type owl:DatatypeProperty ;
  rdfs:label "max depth"^^xsd:string ;
  rdfs:range xsd:nonNegativeInteger ;
.
qudt:maxExclusive
  rdf:type owl:DatatypeProperty ;
  dc:description "maxExclusive is the exclusive upper bound of the value space for a datatype with the ordered property. The value of maxExclusive must be in the value space of the base type or be equal to {value} in {base type definition}." ;
  rdfs:label "max exclusive"^^xsd:string ;
  rdfs:range xsd:string ;
.
qudt:maxExponent
  rdf:type owl:DatatypeProperty ;
  rdf:type owl:FunctionalProperty ;
  rdfs:label "max exponent"^^xsd:string ;
  rdfs:range xsd:nonNegativeInteger ;
.
qudt:maxInclusive
  rdf:type owl:DatatypeProperty ;
  dc:description "maxInclusive is the inclusive upper bound of the value space for a datatype with the ordered property. The value of maxInclusive must be in the value space of the base type." ;
  rdfs:label "max inclusive"^^xsd:string ;
  rdfs:range dtype:numericUnion ;
  rdfs:subPropertyOf qudt:upperBound ;
.
qudt:maxLength
  rdf:type owl:DatatypeProperty ;
  rdfs:label "max length"^^xsd:string ;
  rdfs:range xsd:nonNegativeInteger ;
.
qudt:maxMantissa
  rdf:type owl:DatatypeProperty ;
  dc:description "The maximium mantissa is the largest integer that may appear as a coefficient in a finite precision representation of a real number.  For a given numeric data type, the value of \\textit{maxMantissa} ($M$) and the values of \\textit{base} ($b$) and \\textit{precision} ($p$) are related by the formula: $M = b^p - 1$ ."^^xsd:string ;
  rdfs:label "max mantissa"^^xsd:string ;
  rdfs:range xsd:integer ;
.
qudt:microsoftSQLServerName
  rdf:type owl:DatatypeProperty ;
  rdfs:label "Microsoft SQL Server name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf qudt:designator ;
.
qudt:minBits
  rdf:type owl:DatatypeProperty ;
  rdfs:label "minimum bits"^^xsd:string ;
  rdfs:range xsd:positiveInteger ;
.
qudt:minExclusive
  rdf:type owl:DatatypeProperty ;
  dc:description "minExclusive is the exclusive lower bound of the value space for a datatype with the ordered property. The value of minExclusive must be in the value space of the base type or be equal to {value} in {base type definition}." ;
  rdfs:label "min exclusive"^^xsd:string ;
  rdfs:range xsd:string ;
.
qudt:minInclusive
  rdf:type owl:DatatypeProperty ;
  dc:description "minInclusive is the inclusive lower bound of the value space for a datatype with the ordered property. The value of minInclusive must be in the value space of the base type." ;
  rdfs:label "min inclusive"^^xsd:string ;
  rdfs:range dtype:numericUnion ;
  rdfs:subPropertyOf qudt:lowerBound ;
.
qudt:minLength
  rdf:type owl:DatatypeProperty ;
  rdfs:label "min length"^^xsd:string ;
  rdfs:range xsd:nonNegativeInteger ;
.
qudt:minMantissa
  rdf:type owl:DatatypeProperty ;
  dc:description "The minimium mantissa is the negative integer with the greatest magnitude that may appear as a coefficient in a finite precision representation of a real number.  For a given numeric data type, the value of \\textit{minMantissa} ($M$) and the values of \\textit{base} ($b$) and \\textit{precision} ($p$) are related by the formula: $M = -(b^p - 1)$."^^xsd:string ;
  rdfs:label "min mantissa"^^xsd:string ;
  rdfs:range xsd:integer ;
.
qudt:minValue
  rdf:type owl:DatatypeProperty ;
  rdfs:label "minimum value"^^xsd:string ;
  rdfs:range dtype:numericUnion ;
.
qudt:mySQLName
  rdf:type owl:DatatypeProperty ;
  rdfs:label "MySQL name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf qudt:designator ;
.
qudt:octets
  rdf:type owl:DatatypeProperty ;
  rdfs:label "octets"^^xsd:string ;
  rdfs:range xsd:positiveInteger ;
.
qudt:odbcName
  rdf:type owl:DatatypeProperty ;
  rdfs:label "ODBC name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf qudt:designator ;
.
qudt:oleDBName
  rdf:type owl:DatatypeProperty ;
  dc:description "OLE DB (Object Linking and Embedding, Database, sometimes written as OLEDB or OLE-DB), an API designed by Microsoft, allows accessing data from a variety of sources in a uniform manner. The API provides a set of interfaces implemented using the Component Object Model (COM); it is otherwise unrelated to OLE. "^^xsd:string ;
  rdfs:label "OLE DB name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf qudt:designator ;
  prov:wasInfluencedBy <http://en.wikipedia.org/wiki/OLE_DB> ;
  prov:wasInfluencedBy <http://msdn.microsoft.com/en-us/library/windows/desktop/ms714931(v=vs.85).aspx> ;
.
qudt:oracleSQLName
  rdf:type owl:DatatypeProperty ;
  rdfs:label "ORACLE SQL name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf qudt:designator ;
.
qudt:orderedType
  rdf:type owl:ObjectProperty ;
  rdfs:label "ordered type"^^xsd:string ;
.
qudt:orderingRelation
  rdf:type owl:FunctionalProperty ;
  rdf:type owl:ObjectProperty ;
  vaem:description "This property identifies the mathematical comparison operator (such as \"<\" or \">\") that is used to order the elements of a collection."^^xsd:string ;
  rdfs:label "Ordering Relation"^^xsd:string ;
.
qudt:originDefinition
  rdf:type owl:DatatypeProperty ;
  rdfs:label "origin definition"^^xsd:string ;
  rdfs:range xsd:string ;
.
qudt:padding
  rdf:type owl:ObjectProperty ;
  rdfs:label "padding"^^xsd:string ;
.
qudt:pattern
  rdf:type owl:DatatypeProperty ;
  dc:description "A pattern is a constraint on the value space of a datatype which is achieved by constraining the lexical space to literals which match a specific pattern. The value of pattern must be a regular expression." ;
  rdfs:label "pattern"^^xsd:string ;
  rdfs:range xsd:string ;
.
qudt:pitchRotationDefinition
  rdf:type owl:ObjectProperty ;
  rdfs:label "pitch rotation definition"^^xsd:string ;
  rdfs:subPropertyOf qudt:rotationDefinition ;
.
qudt:precision
  rdf:type owl:DatatypeProperty ;
  rdf:type owl:FunctionalProperty ;
  vaem:description """Precision is the number of digits used to perform a given computation. The concepts of accuracy and precision are both closely related and often confused. While the accuracy of a number x is given by the number of significant decimal (or other) digits to the right of the decimal point in x, the precision of x is the total number of significant decimal (or other) digits.

For a given numeric data type, the value of type:precision (?p) is related to the values of type:maxMantissa (?M) and type:base (?b) by the formula 

?p := log(?b, ?M) 

where log(a,y) = x iff y=a^x."""^^xsd:string ;
  rdfs:label "precision"^^xsd:string ;
  rdfs:range xsd:nonNegativeInteger ;
.
qudt:pythonName
  rdf:type owl:DatatypeProperty ;
  rdfs:label "python name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf qudt:designator ;
.
qudt:rdfsDatatype
  rdf:type owl:ObjectProperty ;
  rdfs:label "rdfs datatype"^^xsd:string ;
.
qudt:realization
  rdf:type owl:DatatypeProperty ;
  rdfs:label "realization"^^xsd:string ;
  rdfs:range xsd:string ;
.
qudt:referenceFrame
  rdf:type owl:ObjectProperty ;
  rdfs:label "reference frame"^^xsd:string ;
  rdfs:subPropertyOf qudt:coordinateSystemFrame ;
.
qudt:referenceFrameType
  rdf:type owl:ObjectProperty ;
  rdfs:label "reference frame type"^^xsd:string ;
.
qudt:returnType
  rdf:type owl:ObjectProperty ;
  vaem:description "This property is used to state the return type of a function type."^^xsd:string ;
  rdfs:label "return type"^^xsd:string ;
  rdfs:subPropertyOf qudt:elementType ;
.
qudt:rollRotationDefinition
  rdf:type owl:ObjectProperty ;
  rdfs:label "roll rotation definition"^^xsd:string ;
  rdfs:subPropertyOf qudt:rotationDefinition ;
.
qudt:rotationDefinition
  rdf:type owl:ObjectProperty ;
  rdfs:label "rotation definition"^^xsd:string ;
.
qudt:rows
  rdf:type owl:DatatypeProperty ;
  rdfs:label "rows"^^xsd:string ;
  rdfs:range xsd:positiveInteger ;
.
qudt:signedness
  rdf:type owl:ObjectProperty ;
  rdfs:label "signedness"^^xsd:string ;
.
qudt:string1
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "string1"^^xsd:string ;
  rdfs:subClassOf xsd:string ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:length "1"^^xsd:string ;
          ]
        ) ;
    ] ;
  owl:length "1"^^xsd:nonNegativeInteger ;
.
qudt:string1024
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "string1024"^^xsd:string ;
  rdfs:subClassOf xsd:string ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:maxLength "1024"^^xsd:nonNegativeInteger ;
          ]
        ) ;
    ] ;
  owl:length "1024"^^xsd:nonNegativeInteger ;
.
qudt:string16
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "string16"^^xsd:string ;
  rdfs:subClassOf xsd:string ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:maxLength "16"^^xsd:nonNegativeInteger ;
          ]
        ) ;
    ] ;
  owl:length "16"^^xsd:nonNegativeInteger ;
.
qudt:string2
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "string2"^^xsd:string ;
  rdfs:subClassOf xsd:string ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:maxLength "2"^^xsd:nonNegativeInteger ;
          ]
        ) ;
    ] ;
  owl:length "2"^^xsd:nonNegativeInteger ;
.
qudt:string3
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "string3"^^xsd:string ;
  rdfs:subClassOf xsd:string ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:maxLength "3"^^xsd:nonNegativeInteger ;
          ]
        ) ;
    ] ;
  owl:length "3"^^xsd:nonNegativeInteger ;
.
qudt:string32
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "string32"^^xsd:string ;
  rdfs:subClassOf xsd:string ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:maxLength "32"^^xsd:nonNegativeInteger ;
          ]
        ) ;
    ] ;
  owl:length "32"^^xsd:nonNegativeInteger ;
.
qudt:string4
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "string4"^^xsd:string ;
  rdfs:subClassOf xsd:string ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:maxLength "4"^^xsd:nonNegativeInteger ;
          ]
        ) ;
    ] ;
  owl:length "4"^^xsd:nonNegativeInteger ;
.
qudt:string64
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "string64"^^xsd:string ;
  rdfs:subClassOf xsd:string ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:maxLength "64"^^xsd:nonNegativeInteger ;
          ]
        ) ;
    ] ;
  owl:length "64"^^xsd:nonNegativeInteger ;
.
qudt:string8
  rdf:type rdfs:Datatype ;
  rdf:type owl:DataRange ;
  rdfs:label "string8"^^xsd:string ;
  rdfs:subClassOf xsd:string ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:string ;
      owl:withRestrictions (
          [
            xsd:maxLength "8"^^xsd:nonNegativeInteger ;
          ]
        ) ;
    ] ;
  owl:length "8"^^xsd:nonNegativeInteger ;
.
qudt:typeMatrix
  rdf:type owl:ObjectProperty ;
  rdfs:label "type matrix"^^xsd:string ;
.
qudt:typeVector
  rdf:type owl:ObjectProperty ;
  rdfs:label "type vector"^^xsd:string ;
.
qudt:upperBound
  rdf:type owl:DatatypeProperty ;
  rdfs:label "upper bound"^^xsd:string ;
  rdfs:range xsd:anySimpleType ;
.
qudt:valueType
  rdf:type owl:ObjectProperty ;
  rdfs:label "value type"^^xsd:string ;
.
qudt:vbName
  rdf:type owl:DatatypeProperty ;
  rdfs:label "visual basic name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf qudt:designator ;
.
qudt:xAxisDefinition
  rdf:type owl:DatatypeProperty ;
  dc:description "The definition of the X-Axis could be an intersection, cross-product or other function of a  meridian or orbit. It could also mention any aspects of rotation, for example, the rotation equator of the Earth,  Sun, Moon or other celestial body. An epoch might also be given."^^xsd:string ;
  rdfs:label "X-Axis Definition"^^xsd:string ;
  rdfs:range xsd:string ;
.
qudt:xCoordinateDefinition
  rdf:type owl:DatatypeProperty ;
  rdfs:label "X-Coordinate definition"^^xsd:string ;
  rdfs:range xsd:string ;
.
qudt:yAxisDefinition
  rdf:type owl:DatatypeProperty ;
  dc:description "The definition of the Y-Axis could be an intersection, cross-product or other function of a meridian or orbit. It could also mention any aspects of rotation, for example, the rotation equator of the Earth,  Sun, Moon or other celestial body. An epoch might also be given."^^xsd:string ;
  rdfs:label "Y-Axis definition"^^xsd:string ;
  rdfs:range xsd:string ;
.
qudt:yCoordinateDefinition
  rdf:type owl:DatatypeProperty ;
  rdfs:label "Y-Coordinate definition"^^xsd:string ;
  rdfs:range xsd:string ;
.
qudt:yawRotationDefinition
  rdf:type owl:ObjectProperty ;
  rdfs:label "Yaw rotation definition"^^xsd:string ;
  rdfs:subPropertyOf qudt:rotationDefinition ;
.
qudt:zAxisDefinition
  rdf:type owl:DatatypeProperty ;
  dc:description "The definition of the Y-Axis could be an intersection, croos-product or other function of a meridian or orbit. It could also mention any aspects of rotation, for example, the rotation equator of the Earth,  Sun, Moon or other celestial body. An epoch might also be given."^^xsd:string ;
  rdfs:label "Z-Axis definition"^^xsd:string ;
  rdfs:range xsd:string ;
.
qudt:zCoordinateDefinition
  rdf:type owl:DatatypeProperty ;
  rdfs:label "Z-Coordinate definition"^^xsd:string ;
  rdfs:range xsd:string ;
.
<http://qudt.org/vocab/type/BigEndian>
  qudt:description "A big-endian machine stores the most significant byte first."^^xsd:string ;
.
<http://qudt.org/vocab/type/BitAligned>
  qudt:description "Alignment at a bit level."^^xsd:string ;
.
<http://qudt.org/vocab/type/ByteAligned>
  qudt:description "Alignment of a field at a byte boundary."^^xsd:string ;
.
<http://qudt.org/vocab/type/LittleEndian>
  qudt:description "A little-endian machine stores the least significant byte first."^^xsd:string ;
.
<http://qudt.org/vocab/type/NegativeX>
  qudt:description "The axis that is in the negative X direction."^^xsd:string ;
.
<http://qudt.org/vocab/type/NegativeY>
  qudt:description "The axis that is in the negative Y direction."^^xsd:string ;
.
<http://qudt.org/vocab/type/NegativeZ>
  qudt:description "The axis that is in the negative Z direction."^^xsd:string ;
.
<http://qudt.org/vocab/type/PadWithAny>
  qudt:description "Pad with either a one or a zero. In other words, this is the \"don't care\" situation."^^xsd:string ;
.
<http://qudt.org/vocab/type/PadWithOnes>
  qudt:description "Pad unused bits of a field with a one."^^xsd:string ;
.
<http://qudt.org/vocab/type/PadWithZeros>
  qudt:description "Pad unused bits of a field with a zero."^^xsd:string ;
.
<http://qudt.org/vocab/type/PositiveX>
  qudt:description "The axis that is in the positive X direction."^^xsd:string ;
.
<http://qudt.org/vocab/type/PositiveY>
  qudt:description "The axis that is in the positive Y direction."^^xsd:string ;
.
<http://qudt.org/vocab/type/PositiveZ>
  qudt:description "The axis that is in the positive Z direction."^^xsd:string ;
.
<http://qudt.org/vocab/type/WordAligned>
  qudt:description "Alignment of a field at a word boundary, that is 2 bytes."^^xsd:string ;
.
xsd:dateTime
  dc:description "YYYY-MM-DDThh:mm:ss[.dd] or YYYY-DDDThh:mm:ss[.dd], where 'YYYY' is the year, 'MM' is the two-digit month, 'DD' is the two-digit day, 'DDD' is the three digit day of year, 'T' is constant, 'hh:mm:ss[.dd]' is the UTC time in hours, minutes, seconds, and optional fractional seconds. As many 'd' characters to the right of the period as required may be used to obtain the required precision. All fields require leading zeros."^^xsd:string ;
.
[
  rdf:type owl:Restriction ;
  owl:allValuesFrom qudt:ScalarDatatype ;
  owl:onProperty qudt:encoding ;
].
[
  rdf:type owl:Restriction ;
  owl:cardinality "1"^^xsd:int ;
  owl:onProperty qudt:realization ;
].
[
  rdf:type owl:Restriction ;
  owl:cardinality "1"^^xsd:int ;
  owl:onProperty qudt:xAxisDefinition ;
].
[
  rdf:type owl:Restriction ;
  owl:cardinality "1"^^xsd:int ;
  owl:onProperty qudt:xAxisDefinition ;
].
[
  rdf:type owl:Restriction ;
  owl:cardinality "1"^^xsd:int ;
  owl:onProperty qudt:yAxisDefinition ;
].
[
  rdf:type owl:Restriction ;
  owl:cardinality "1"^^xsd:int ;
  owl:onProperty qudt:yAxisDefinition ;
].
[
  rdf:type owl:Restriction ;
  owl:cardinality "1"^^xsd:int ;
  owl:onProperty qudt:zAxisDefinition ;
].
[
  rdf:type owl:Restriction ;
  owl:cardinality "1"^^xsd:int ;
  owl:onProperty qudt:zAxisDefinition ;
].
[
  rdf:type owl:Restriction ;
  owl:maxCardinality "1"^^xsd:int ;
  owl:onProperty qudt:bitOrder ;
].
[
  rdf:type owl:Restriction ;
  owl:maxCardinality "1"^^xsd:int ;
  owl:onProperty qudt:byteOrder ;
].
[
  rdf:type owl:Restriction ;
  owl:maxCardinality "1"^^xsd:int ;
  owl:onProperty qudt:xCoordinateDefinition ;
].
[
  rdf:type owl:Restriction ;
  owl:maxCardinality "1"^^xsd:int ;
  owl:onProperty qudt:yCoordinateDefinition ;
].
[
  rdf:type owl:Restriction ;
  owl:maxCardinality "1"^^xsd:int ;
  owl:onProperty qudt:zCoordinateDefinition ;
].
